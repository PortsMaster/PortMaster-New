
//======================================================================
// ENTITIES FGD file (Trenchbroom Only)
// 
// MOD    : Arcane Dimensions v1.80
// Date   : Sometime in 2020
// Author : Dan "twitchy/damage_inc" Ellis & Benoit "Bal" Stordeur & Probably some other people before us!
// Editor : Trenchbroom
// Tools  : Ericw-Tools v0.18.1( https://ericwa.github.io/ericw-tools/ )
//
// Arcane Dimensions is a pretty huge mod with lots of new features, I'm sure there are some bugs
// in this FGD file, or maybe some missing things. Please contact me (Bal) if you find anything that
// seems wrong!
//
//======================================================================

@baseclass = AppearFlags [
	spawnflags(Flags) =
	[
		256 : "Not in Easy" : 0 : "Will not spawn for EASY skill"
		512 : "Not in Normal" : 0 : "Will not spawn for NORMAL skill"
		1024 : "Not in Hard" : 0 : "Will not spawn for HARD skill"
		2048 : "Not in Deathmatch" : 0 : "Will not spawn for DEATHMATCH skill"
	]
]

@baseclass = targetname [ targetname(target_source) : "Name" : : "Name of entity, used for triggering/targetting other entities" ]
@baseclass = target [ target(target_destination) : "Target" : : "Targets to affect" ]
@baseclass = target2 [ target2(target_destination) : "Target2" : : "More targets to affect" ]

//======================================================================
//
// WORLDSPAWN
//
//======================================================================

@SolidClass = worldspawn : "World entity"
[
	//----------------------------------------------------------------------
	worldtype(choices) : "World Type" : 0 = [
		0 : "Medieval"
		1 : "Runic (metal)"
		2 : "Present (base)"
	]
	message(string) : "Level Name" : : "Enter a level name that will show ingame when the player presses 'Tab', otherwise it's just the name of the bsp file minus the extension."
	sounds(integer) : "Music/CD track (ex: 07)" :  : "Music track to automatically play. Modern engines allow custom(non-cd) music tracks(.ogg/.mp3) typically named with the format of: track01,  track02... track99 etc. Only the trailing numbers are required for this value. NOTE - Quakespasm looks for music files in '... id1/music' while Darkplaces looks in '... id1/sound/cdtracks'. Using a Mod directory is also acceptable(ex '... ad/music' or '... ad/sound/cdtracks'."
	wad(string) : "Wads" : "" : "List of Wad files used by the compiler, use a ';' for seperation)."
    sky(string) : "Sky Texture" :  : "Use a Skybox instead of an id standard animated sky. Skyboxes(.tga) consist of 6 images and are typically referenced as: interstellar_, moonrise_, voidsmoke_ etc with these letters(bk, dn, ft, lf, rt, and up) appended at the end. The underscore is not neccesary but used for clarity. The important part is to just leave off the last 'two' trailing letters from the name of your skybox for 'Sky Texture' here. NOTE: Directory paths are allowed so, '...env/mycustomfolder/mycustomsky_' is perfectly valid. FYI - Quakespasm/Darkplaces both look for skybox files in '...id1/gfx/env/'. Using a Mod directory is also acceptable(ex '... ad/gfx/env'."
    gravity(integer) : "Gravity" :  : "Gravity of the map, default 800."
	passive_state(choices) : "Global Passive State" : :  "All monsters are setup in a passive state." = [
		0 : "Off, Normal behaviour"
		1 : "On, All monsters are Passive"
	]
	no_trackondeath(choices) : "Homing on Death" : : "Homing missiles stop tracking when monsters die." = [
		0 : "Off, homing missiles track after death"
		1 : "On, homing missiles stop tracking after death"
	]
	hazard_dmg(vector) : "Hazard Damage Change" : : "Hazard damage override for the map, x,y,z for water,slime,lava (2,4,10 is default)"
    
//-------- World Lighting Options  --------
  
	_minlight(integer) : "Ambient Light" :  : "Set a global minimum light level(Default 0). While this can help light completey black areas of your map, it can also have unwanted side affects(lost contrast) globally on all of your lights/shadows. Use with caution."
	_minlight_color(color255) : "Ambient Light Color" :  : "Sets the global minimum light color. Default white(255 255 255)."
	_minlight_dirt(choices) : "Ambient Light Dirt(AO)" :  : "1 enables dirtmapping (ambient occlusion) on minlight lit surfaces, -1 to disable. Default is to use the value of '_dirt'." = [
        -1 : "Disabled"
         0 : "Default"
         1 : "Enabled"
    ]   	
	_range(integer) : "Global Light Range" :  : "Scales the brightness range of all lights without affecting their fade distance. Values more than 0.5 makes lights brighter and values less than 0.5 makes lights less bright. The same effect can be achieved on individual lights by adjusting both the 'light' and 'wait' attributes."
	_dist(integer) : "Global Light Scale" :  : "Scales the fade distance of all lights by a factor of 'n'. If 'n' is more than 1 lights fade more quickly with distance and if 'n' is less than 1, lights fade more slowly with distance and the light reaches further."
	_gamma(integer) : "Lightmap gamma" :  : "Adjust brightness of the final lightmap. Default 1, >1 is brighter, <1 is darker."
	_spotlightautofalloff(integer) : "Spotlight Falloff" :  : "When set to 1, spotlight falloff is calculated from the distance to the targeted 'info_null'. Ignored when '_falloff' is not 0. Default 0."

//-------- SUN options --------

	_sunlight(integer) : "Sunlight" :  : "Set the brightness of the sunlight coming from an unseen sun in the sky. Sky brushes, or more accurately bsp leafs with sky contents, will emit sunlight at an angle specified by the '_sunlight_mangle' key. Default 0."
	_sunlight_color(color255) : "Sunlight Color" :  : "Specify the red(r), green(g) and blue(b) components for the colour of the sunlight. Default is white(255 255 255)." 
	_sunlight_mangle(string) : "Sunlight Direction" :  : "Specifies the direction of sunlight using yaw(x), pitch(y) and roll(z) in degrees. Yaw specifies the angle around the Z-axis from 0 to 359 degrees, in a counter clockwise rotation. Looking top down(top=X/Y) in the editor, a yaw value of 1/359 is effectively placing the Sun's starting position at 9:00 A.M. Pitch specifies the angle from 90 'straight up' to -90 'straight down'. Roll has no effect(use 0). Default is straight down (0 -90 0)."
	_anglescale(integer) : "Sunlight Angle Scale" :  : "Sets a scaling factor for how much influence, the angle of incidence, sunlight has on the brightness of a surface. Values must be between '0.0' and '1.0'. Smaller values mean less attenuation, with zero meaning that angle of incidence has no effect at all on the brightness. Default 0.5"
	_sunlight_dirt(choices) : "Sunlight Dirt" :  : "1 enables dirtmapping (ambient occlusion) on sunlight, -1 to disable (making it illuminate the dirtmapping shadows). Default is to use the value of '_dirt'." = [
		-1 : "Disabled"
		 0 : "Default"
		 1 : "Enabled"
	]
	_sunlight_penumbra(integer) : "Sunlight Penumbra" :  : "Specifies the penumbra width, in degrees, of sunlight. Useful values are 3-4 for a gentle soft edge, or 10-20+ for more diffuse sunlight. Default is 0."
	_sunlight2(integer) : "Sunlight 2" :  : "Set the brightness of a large dome of lights positioned around the map (16K unit radius). Useful for simulating higly diffused light (e.g. cloudy skies) in outdoor areas (def=0)."
	_sunlight2_color(color255) : "Sunlight 2 color" :  : "Specifies the color of '_sunlight2', same format as '_sunlight_color'. Default (255 255 255)"
	_sunlight2_dirt(choices) : "Sunlight 2 dirt" :  : "1 enables dirtmapping (ambient occlusion) on sunlight2, -1 to disable. Default is to use the value of '_dirt'." = [
		-1 : "Disabled"
		 0 : "Default"
		 1 : "Enabled"
	]
	_sunlight3(integer) : "Sunlight 3" :  : "Same as _sunlight2, but for the bottom hemisphere, where ambient light is coming from below the horizon. Combine '_sunlight2' and '_sunlight3' to have light coming equally from all directions. Useful in levels with a Sky/Void theme. Default 0."
	_sunlight3_color(color255) : "Sunlight 3 color" :  : "Specifies the color of '_sunlight3', same format as '_sunlight_color'. Default (255 255 255)"

//-------- Fog Options --------------------

	fog(string) : "Fog Command" :  : "ENGINE only 'console command' for setting fog parameters, Density/R/G/B example = (0.05 0.3 0.3 0.3). NOTE- If you plan to use 'trigger_fog' in your map, be sure to set both INDIVIDUAL 'Fog Density' and 'Fog Colour' values for proper operation."
	fog_density(integer) : "Fog Density" :  : "Global fog density (def 0.1). NOTE - An Initial value MUST be entered for proper 'trigger_fog' operation."
	fog_colour(color1) : "Fog Colour" :  : "Initial global fog colour (def 0.1 0.1 0.1). NOTE - An initial value MUST be entered for proper trigger_fog operation."
	fog_dpextra(string) : "Fog DP Extra" :  : "Extra fog parameters for Darkplaces, (def= 1 0 8192 1024 32)."
	skyfog_density(integer) : "Sky Fog Density" : : "Trigger skyfog starting density (default = 0.5)"
	
//-------- Liquid Options --------------------
  
	water_alpha(string) : "Water Alpha" :  : "Set the transpareny of water (ex .70), which are brushes textured with a water(ex *04water) texture. This setting tranfers directly to the other 'liquid' types and teleporters, UNLESS you are using an engine that supports individual 'alpha's' for each(see below). NOTE - Defaults to the players own 'r_wateralpha' settings if no value is assigned. REQUIRED to be set if you intend to use separate transparencies for other liquid types."
	lavaalpha(string) : "Lava Alpha" :  : "Set the individual transparency of Lava, brush solids textured with a lava(ex *lava1) texture. Default inherits the 'water_alpha' setting. If 'water_alpha' is not set then it defaults to the players own 'r_wateralpha' setting."
	slimealpha(string) : "Slime Alpha" :  : "Transparency of Slime, works the same as 'lavaalpha' except for solids textured with a slime(ex *slime0) texture."
	telealpha(string) : "Teleporter Alpha" :  : "Transparency of Teleporters, works the same as 'lavaalpha' except for solids textured with a teleporter(ex *teleport) texture."
	
//-------- Ambient Occlusion options -------------	
   
	_dirt(choices) : "Dirt Mapping (AO)" :  : "1 Enables dirtmapping (ambient occlusion) on all lights adding  shadows to corners and crevices. You can override the global setting for specific lights with the '_dirt' key, for point light entities, and the '_sunlight_dirt', '_sunlight2_dirt', '_minlight_dirt' keys, in worldspawn. Default -1, no dirtmapping." = [
		-1 : "Disabled"
		 0 : "Default"
		 1 : "Enabled"
	]
	_dirtmode(choices) : "Dirt mode" :  : "Choose between ordered or randomized dirtmapping, default 0" = [
		 0 : "Ordered (def)"
		 1 : "Randomized"
	]
	_dirtscale(integer) : "Dirt scale" :  : "Scale factor used in dirt calculations. Lower values(ex 0.5) make the dirt fainter while larger values (ex 2.0) would create much darker shadows, default 1."
	_dirtgain(integer) : "Dirt Gain" :  : "Exponent used in dirt calculation. Lower values(ex 0.5) make the shadows darker and stretch further away from corners, default 1."
	_dirtdepth(integer) : "Dirt Depth" :  : "Maximum depth of occlusion checking for dirtmapping, default 128."
	_dirtangle(integer) : "Dirt Angle" :  : "Cone angle in degrees for occlusion testing. Lower values can avoid unwanted dirt on arches, pipes, interiors etc. Allowed range is (x=1->90), default 88."
	
//-------- Bounce Lighting Options ---------------

    _bounce(choices) : "Bounce Lighting" :  : "1 enables bounce lighting, default 0." = [
		 0 : "Default"
		 1 : "Enabled"
	] 
    _bouncescale(integer) : "Bounce Scale" :  : "Scales the brightness of bounce lighting, default 1."
    _bouncecolorscale(choices) : "Bounce Color" :  : "Weight for bounce lighting to use texture colors from the map. 0 ignores map textures (default), 1 multiplies bounce light color by texture color." = [
		 0 : "Default"
		 1 : "Enabled"
	] 
    _bouncestyled(choices) : "Bounce Styled Lights" :  : "1 makes styled lights bounce (e.g. flickering or switchable lights), default is 0, they do not bounce." = [
		 0 : "Default"
		 1 : "Enabled"
	] 
	
//-------- Arcane Dimension Options--------------------

	no_item_offset(choices) : "Item Offset for ammo/health" = [
		-1 : "Disabled"
		 0 : "Use Default"
		 1 : "Enabled"
	]
	//QC states: "An old worldspawn key (not used anymore)"
	//no_item_rotate(choices) : "Item Rotate for ammo/health" = [
	//	-1 : "Disabled"
	//	 0 : "Enabled"
	//]
	no_zaware(choices) : "Monsters - Z Aware attacks" = [
		-1 : "Disabled"
		 0 : "Use Default"
		 1 : "Enabled"
	]	
	no_liquiddmg(choices) : "Monsters - slime/lava Damage" = [
		-1 : "Disabled"
		 0 : "Use Default"
		 1 : "Enabled"
	]
	knight_defskin(choices) : "Default Red knight skin" = [
		0 : "Default - Red"
		1 : "No colour, grey"
		2 : "Vertical stripes"
		3 : "Swampy green/red"
	]
	bodyflrcheck(choices) : "Monster dead body check floor" = [
		0 : "(Default) No Check"
		1 : "Yes - Check for gravity"
	]
	bodyfadeaway(integer) : "Monster dead body fade timer" :  : "Time in seconds"
	playerweather(string) : "Name of weather effect active above player"
	ckeyhint(integer) : "Set to 1 to supress the Arcane Key inventory messages"
	plasmagun_dmg(integer) : "Plasma gun damage override" : : "Plasma gun damage override, x y z where x is direct damage, y is random additional damage, z is splash damage (def=45 0 20). A high splash damage will alow plasma climbing."
	no_moncountdevmsg(integer) : "Set to 1 to stop monster-no-count warning messages in Dev console"
	
//_____Weapons /Ammo / Health Setup_____

	upgrade_axe(choices) : "Upgrade Axe" = [
		-1 : "Remove from Inventory"
		 0 : "Use Default"
		 1 : "Add to Inventory"
	]
	upgrade_ssg(choices) : "Upgrade Shotgun" = [
		-1 : "Remove from Inventory"
		 0 : "Use Default"
		 1 : "Add to Inventory"
	]
	upgrade_lg(choices) : "Upgrade Lightning Gun" = [
		-1 : "Remove from Inventory"
		 0 : "Use Default"
		 1 : "Add to Inventory"
	]
	give_weapons(integer) : "Give weapons at start" :  : "SG=1, SSG=2, NG=4, SNG=8, GL=16, RL=32, LG=64"
	take_weapons(integer) : "Take weapons away at start" :  : "SG=1, SSG=2, NG=4, SNG=8, GL=16, RL=32, LG=64"
	max_health(integer) : "Minimum Health at start" :  : "Update player health if below this value"
	reset_health(integer) : "Reset Health at start" :  : "Reset player health to this value"
	currentammo(choices) : "Setup Players Ammo" = [
		0 : "Minimum values"
		1 : "Reset values"
	]
	ammo_shells(integer) : "Ammo Shells" :  : "Player starting quantity"
	ammo_nails(integer) : "Ammo Nails" :  : "Player starting quantity"
	ammo_rockets(integer) : "Ammo Rockets" :  : "Player starting quantity"
	ammo_cells(integer) : "Ammo Cells" :  : "Player starting quantity"
	armortype(choices) : "Armour Type" = [
		0 : "No Armour given"
		1 : "Green Armour"
		2 : "Yellow Ammour"
		3 : "Red Armour"
	]
	armourvalue(integer) : "Armour Quantity" :  : "Quantity of armour to reset player (100/150/200)"
	no_axestart(integer) : "Set to 1 to start the player with no axe and no shotgun!"
	
//_____Engine  Setup_____ 
 
	sprite_particles(choices) : "Sprite Particles ONLY" :  : "Switch all custom particles to sprites (builtins excluded)." = [
		 0 : "Default"
		 1 : "Enabled"
    ]
    particlemax(integer) : "Max ACTIVE Particles" :  : "Amount of ACTIVE particles per map"
    
    no_sgprojectile(choices) : "Hide Shotgun Projectiles" = [
	    -1 : "Disabled"
		 0 : "Use Default"
		 1 : "Enabled"	
	]
	no_sgcasing(choices) : "Hide Shotgun Casings" = [
	    -1 : "Disabled"
		 0 : "Use Default"
		 1 : "Enabled"	
	]    
    no_bigprojectiles(choices) : "AD Style Projectiles (small)": : "Turn OFF standard ID Software style 'large player' projectile sizes(collision boxes). This change affects the following ammo type/weapons: shells(SG/SSG/WSG), nails(NG/SNG), rockets(RL) and cells(PG). NOTE: This may make the game more challenging, but may also have the side affect of making it less fun. You can toggle this yourself with the 'impulse 105' console command." = [
		 0 : "Default(OFF)"
		 1 : "Enabled"
    ]    
    mapvar_update(string) : "Map Variables (Range X->Y=Z)" :  : "Essentially (X->Y=Z) simply states that, X thru Y is a range of variables(0-132 available) and that Z is a value of either 0 or 1. Thus, setting 'mapvar_update' to '0 3 1' would set variables 0 thru 3 to equal 1."
	compilerstyle_start(integer) : "Starting point for target lights (set by compiler)"
  
 //Patch2 additions  
 //_____Jumping and Falling_____ 
 
   	jump_height(integer) : "Jump boots velocity (def=270)" : : "When jumping you get a 270 velocity boost, which combined with other movement can be up to 600+"
   	fall_dmg(integer) : "Fall damage (def=5, <-1=no dmg/sound)" : : "Custom fall damage, values <-1 disables sound and damage"
	fall_dmgwater(integer) : "Water damage (def=0, >0=dmg+sound)" : :  "Custom water damage, from falling, values >0 enables sound and damage"  
	fall_heightlow(integer) : "Fall height sound only (no dmg (def=300)" : : "Custom fall height that triggers a thud sound without inflicting player damage"
	fall_heighthigh(integer) : "Fall height sound+damage (def=650)" : : "Custom fall height that triggers a bone crush sound with inflicting player damage"	
	fall_speeddebug(integer) : "Set to 1 to display players fall velocity to console"
]

//======================================================================
//
// Ambient Sounds
//
//======================================================================

//_____Standard Quake Sounds_____
@baseclass base(AppearFlags) size(-16 -16 -8, 16 16 8) color(128 25 204) iconsprite("sprites/speaker.spr") = common []
@PointClass base(common) = ambient_comp_hum : "Computer background sounds" []
@PointClass base(common) = ambient_drip : "Dripping sound" []
@PointClass base(common) = ambient_drone : "Engine/machinery sound" []
@PointClass base(common) = ambient_flouro_buzz : "Fluorescent buzzing sound" []
@PointClass base(common) = ambient_hum1 : "Teleporter Hum sound" []
@PointClass base(common) = ambient_light_buzz : "Buzzing sound from light" []
@PointClass base(common) = ambient_suck_wind : "Wind sound" []
@PointClass base(common) = ambient_swamp1 : "Frogs croaking" []
@PointClass base(common) = ambient_swamp2 : "Frogs croaking B" []
@PointClass base(common) = ambient_thunder : "Thunder sound" []
//_____Custom Sounds_____
//setup base for custom sounds
@baseclass base(targetname,AppearFlags) size(-16 -16 -8, 16 16 8) color(230 230 0) iconsprite("sprites/ambient_custom.spr") = CustomSound []

//_____CUSTOM LOOP_____
//Custom LOOP and WATER don't inherit anything as it's a "set it and forget it" entity
@PointClass size(-16 -16 -8, 16 16 8) color(230 230 0) iconsprite("sprites/ambient_custom.spr") = ambient_custom_loop : "Ambient Custom Loop - Must be a 'looped' sound. Specifically, a '.wav' file with 'markers' placed in it by an Audio editing program(ex Wavosaur). By it's nature, you CANNOT toggle or switch it's state." [	
	volume(choices) : "Volume" :  : "Volume of sound (0.1->1,(default=1 (capped at 1)." = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	noise(sound) : "Custom sound (looped)" :  : "Path/sound file to play (ex ambience/windgust1.wav)."
]
//_____CUSTOM SOUND_____
@PointClass base(AppearFlags,targetname) size(-16 -16 -8, 16 16 8) color(230 230 0) iconsprite("sprites/ambient_custom.spr") = ambient_custom_sound : "Ambient Custom Sound" [
	spawnflags(Flags) = [
		2 : "Play Once" : 0 : "When triggered play only once"
		//Patch2 addition
		4 : "Trigger Only" : 0 : "Constantly waits for trigger events (retrigger)" 
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	target(string) : "Sound Trigger" :  : "Fires each time the sound is played."
	volume(choices) : "Volume" :  : "Volume of sound (default=1, capped at 1)." = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	noise(sound) : "Sound Primary" :  : "Path/sound file (ambience/windgust1a.wav)."
	noise1(sound) : "Sound Stop" :  : "Path/sound file (ambience/switch6_off.wav)."
	noise2(sound) : "Sound Random" :  : "Path/sound file (ambience/windgust1b.wav)."
	wait(integer) : "Random time" :  : "Random Time between sounds (default 20)."
	delay(integer) : "Minimum time" :  : "Time between sounds (default 2)."
	waitmin(integer) : "Starting delay" :  : "Initial starting time of sound (delay + random() x waitmin)."
	waitmin2(integer) : "Do Not Silence" : : "Will not silence sound if switching off."
	impulse(integer) : "Channel" :  : "Channel to play sound (0-7) (0 automatic is default)."
	speed(choices) : "Attenuation" :  : "How quickly the sound fades with distance away from it." = [
	   -1 : "No Attenuation"
		0 : "Default"
		1 : "Normal(def)"
		2 : "Idle"
		3 : "Static"
		4 : "Quiet"
	]
]
//_____WATER_____
@PointClass size(-16 -16 -8, 16 16 8) color(80 160 255) iconsprite("sprites/ambient_custom.spr") = ambient_custom_water : "Play a LOOPED Water Sound. See ambient_custom_loop for 'looping' information." [
	volume(choices) : "Volume" :  : "Volume of Sound (default=.75)" = [
		0.1 : "Barely Audible"
		0.2 : "0.2"
		0.3 : "0.3"
		0.4 : "0.4"
		0.5 : "0.5"
		0.6 : "0.6"
		0.75 : "0.75(def)"
		0.8 : "0.8"
		0.9 : "0.9"
		1.0 : "Full Volume"
	]	
	noise(sound) : "Custom sound" :  : "Custom Sound to Play(default = ambience/water1.wav)"
]
//_____RAIN_____
//Rain does not get spawnflags for 'start off'/'play once'
@PointClass base( CustomSound) = ambient_custom_rain : "Play a rain sound. Always starts off and must be triggered. NOTE - If you re-trigger(ex button) this entity off it will not restart henceforth." [
	spawnflags(Flags) = [
			2 : "Play Once" : 0 : "When triggered play only once"
		   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
		]
    count(choices) : "Type of Rain" = [
       0 : "Default"
       1 : "Fast Dripping"
       2 : "Dowmpour(def)" 
    ]    
	volume(choices) : "Volume" :  : "Volume of sound  (0.1->1,(def=1)." = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
]
//_____CHIME_____
@PointClass base(CustomSound) = ambient_custom_chime : "Play a predefined CHIME sound on a periodic basis. Works with entity state system." [
	spawnflags(Flags) = [
		2 : "Play Once" : 0 : "When triggered play only once"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	volume(choices) : "Volume" :  : "Volume of sound (0.1->1,(def=1)." = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	speed(choices) : "Attenuation" :  : "How quickly the sound fades with distance away from it,(1->4,(def=2)." = [
	   -1 : "No Attenuation"
		0 : "Default"
		1 : "Normal"
		2 : "Idle(def)"
		3 : "Static"
		4 : "Quiet"
	]
    wait(integer) : "Random Time" :  : "Random Time Between Sounds(default 10)."
	delay(integer) : "Minimum Time" :  : "Minimum time between sounds (default 10)."
	waitmin(integer) : "Start Time" : : "Starting time, once the level has loaded (default = 10 + random() x 10)."
]
//_____RUMBLE_____
@PointClass base(CustomSound) = ambient_custom_rumble : "Play a RUMBLE sound on a periodic basis. Works with entity state system." [
	spawnflags(Flags) = [
		2 : "Play Once" : 0 : "When triggered play only once"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	count(choices) : "Type of Rumble" = [
	   -1 : "Random"
	    0 : "Default"
	    1 : "Rumble1"
	    2 : "Rumble2"
	    3 : "Rumble3"
	]
	lefty(choices) : "Alternate Sound" : : "1 = Will alternate between several sound files." = [
		0 : "Default)"
		1 : "Enabled"
	]
//------ Customize Setup ------
	volume(choices) : "Volume" :  : "Volume of sound (0.1->1,(def=0.5)" = [
		0.1 : "Barely Audible"
		0.2 : "0.2"
		0.3 : "0.3"
		0.4 : "0.4"
		0.5 : "0.5(def)"
		0.6 : "0.6"
		0.7 : "0.7"
		0.8 : "0.8"
		0.9 : "0.9"
		1.0 : "Full Volume(def)"
	]
	speed(choices) : "Attenuation" :  : "How quickly the sound fades with distance away from it, (0->4,(def=1)." = [
	   -1 : "No Attenuation"
		0 : "Default"
		1 : "Normal"
		2 : "Idle(def)"
		3 : "Static"
		4 : "Quiet"
	]
    wait(integer) : "Random" :  : "Random Time Between Sounds(default 20)."
	delay(integer) : "Minimum time" :  : "minimum time between sounds (default 20)."
	waitmin(integer) : "Start Time" : : "Starting time once the level has loaded (default = 6 + random() x 6)"
]
//_____WIND_____
@PointClass base(CustomSound) = ambient_custom_wind : "Play a WIND sound on a periodic basis. Works with entity state system." [
	spawnflags(Flags) = [
		2 : "Play Once" : 0 : "When triggered play only once"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	count(choices) : "Type of Wind" = [
	   -1 : "Random"
	    0 : "Default"
	    1 : "Windgust1"
	    2 : "Windgust2"
	    3 : "Windgust3"
	    4 : "Windgust4"
	    5 : "Windgust5"    
	    6 : "Windgust6"
	]
	lefty(choices) : "Alternate Sound" : : "1 = Will alternate between several sound files." = [
		0 : "Default)"
		1 : "Enabled"
	]
//------ Customize Setup ------
	volume(choices) : "Volume" :  : "volume of sound (0.1->1,(def=1)" = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	speed(choices) : "Attenuation" :  : "How quickly the sound fades with distance away from it, (0->4,(def=2)" = [
	   -1 : "No Attenuation"
		0 : "Default"
		1 : "Normal(def)"
		2 : "Idle"
		3 : "Static"
		4 : "Quiet"
	]
    wait(integer) : "Random time" :  : "Random Time Between Sounds(default 10)"
	delay(integer) : "Minimum time" :  : "minimum time between sounds (default 10)"
	waitmin(integer) : "Start Time" : : "Starting time (default = 4 + random() x 4)"	
]
//_____WOOD_____
@PointClass base (CustomSound) = ambient_custom_wood : "Play a WOOD sound on a periodic basis. Works with entity state system." [
	spawnflags(Flags) = [
		2 : "Play Once" : 0 : "When triggered play only once"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	count(choices) : "Type of Creaking" = [
	   -1 : "Random"
	    0 : "Default"
	    1 : "Woodcreak2a"
	    2 : "Woodcreak2b"
	    3 : "Woodcreak2c"
	    4 : "Woodcreak2d"
	]
	lefty(choices) : "Alternate Sound" : : "1 = Will alternate between several sound files." = [
		0 : "Default)"
		1 : "Enabled"
	]
//------ Customize Setup ------	
	volume(choices) : "Volume" :  : "volume of sound (0.1->1,(def=1)" = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	speed(choices) : "Attenuation" :  : "How quickly the sound fades with distance away from it, (0->4,(def=2)" = [
	   -1 : "No Attenuation"
		0 : "Default"
		1 : "Normal"
		2 : "Idle(def)"
		3 : "Static"
		4 : "Quiet"
	]
    wait(integer) : "Random time" :  : "Random Time Between Sounds(default 20)"
	delay(integer) : "Minimum time" :  : "minimum time between sounds (default 20)"
	waitmin(integer) : "Start Time" : : "Starting time (default = 8 + random() x 8)"
]

//======================================================================
//
// INFO entities - player starts, deathmatch, coop, teleport
//
//======================================================================

@baseclass base(AppearFlags) flags(Angle) model("progs/player.mdl") offset(0 0 24) = PlayerClass [
		target(string) : "target(s) fired when used"
	]
@baseclass = StartSpawn2 [ startspawn2(integer) : "Unique spawn location number matching a trigger_changelevel" ]

//_____PLAYER STARTS_____
@PointClass base(PlayerClass) size(-16 -16 -24, 16 16 32) offset(0 0 24) color(255 0 0) = info_player_start : "Player Start" []
@PointClass base(PlayerClass,StartSpawn2) size(-16 -16 -24, 16 16 32) offset(0 0 24) color(230 0 0) = info_player_start2 : "Player Return" []
@PointClass base(PlayerClass,StartSpawn2) size(-16 -16 -24, 16 16 32) offset(0 0 24) color(255 0 255) = info_player_coop : "Player COOP Start" [
	spawnflags(Flags) = [ 64 : "Start OFF" : 0 : "Start off" ]
]
@PointClass base(PlayerClass) size(-16 -16 -24, 16 16 24) color(0 255 255) = info_player_deathmatch : "Player DM Start" [
	spawnflags(Flags) = [ 64 : "Start OFF" : 0 : "Start off" ]
]
@PointClass base(PlayerClass) size(-16 -16 -24, 16 16 32) offset(0 0 24) color(255 0 0) = info_player_startdev : "Player Start in DEVELOPER 1 mode only, for testing purposes" []
//_____TELEPORT_____
@PointClass base(AppearFlags, targetname) flags(Angle) size(-16 -16 -24, 16 16 24) color(255 128 128) offset(0 0 24) = info_teleport_destination : "Teleport destination - The spot you will be teleported to. SEE trigger_teleport." [
		target(target_destination) : "Target (fired when used)"
		teledest(integer) : "Unique number for multiple teleporter destinations"
		angletarget(target_destination) : "targeting entity used for custom direction"
		angles(string) : "Pitch Yaw Roll (destination angle after teleporting)"
]
//_____INTERMISSION_____
@PointClass base(AppearFlags) size(-16 -16 -16, 16 16 16 ) color(255 128 128) flags(Angle) = info_intermission : "This is the camera point for the intermission. You can have multiple cameras and the game will cycle through them in the order they are in the map." [
	spawnflags(Flags) = [
		1 : "No Intermission" : 0 : "Exclude from intermission"
		2 : "Solid Interaction" : 0 : "Solid world interaction"
	]
	target(string) : "target(s) fire when used as a viewing camera"
	mangle(string) : "Mangle (Pitch Yaw Roll)"
	fog_density(integer) : "Fog density (Must be >0 to activate feature)"
	fog_colour(color1) : "Fog colours (def=0.1 0.1 0.1)"
	speed(integer) : "Fog and Skyfog time to change (def=2s)"
	skyfog_density(integer) : "Sky fog density (must be >0 to activate feature)"
	skybox(string) : "Name of skybox to change too"
	]
//_____WIZARD TELEPORT_____
@PointClass base(AppearFlags) size(-16 -16 -24, 16 16 40) color(150 0 200) = info_skullwiz_destination : "Skull Wizard Tele Dest" [
	targetname(string) : "Unique name in chain group"
	target(string) : "Next entity in chain"
	distance(integer) : "Min distance before spawning"
]
//_____INFO's_____
@PointClass base(targetname) size(-4 -4 -4, 4 4 4) color(128 128 128) = info_target : "info_target (Invisible entity)" []
@PointClass base(targetname) size(-4 -4 -4, 4 4 4) color(0 128 0) = info_null : "info_null (spotlight/Sun target)" []
@PointClass base(targetname) size(-4 -4 -4, 4 4 4) color(0 128 0) = info_notnull : "info_notnull (map hack)" [
	use(string) : "self.use"
	think(string) : "self.think"
	nextthink(integer) : "nextthink"
]
//Patch2 addition
@PointClass size(-16 -16 -24, 16 16 32) color(255 128 128) flags(Angle) = info_camera_destination : "Marker for a Cinematic Camera System" [
	targetname(target_source) : "Name (use w/misc_camera)"
	angles(integer) : "Facing angle" : : "Ex: 0 360 0 (pitch yaw roll)"
]

//======================================================================
//
// ITEM entities
//
//======================================================================

@baseclass size(-24 -24 0, 24 24 32) = ItemSize []
@baseclass size(-16 -16 -24, 16 16 32) offset(0 0 24) = PowerupSize []
@baseclass size(-16 -16 -24, 16 16 56) = ArmourSize []
@baseclass size(-16 -16 -24, 16 16 32) offset(0 0 24) = KeySize []

@baseclass base(AppearFlags,targetname) = Items [
	spawnflags(Flags) = [
		16 : "Respawn" : 0 : "Can respawn after being picked up."
		32 : "Floating" : 0 : "Spawns floating, trigger entity to drop it."
		64 : "Start OFF" : 0 : "Starts off and waits for trigger to spawn."
		128 : "No Particles" : 0 : "No particle or effects active on this entity."
	]
	message(string) : "Message (on pick up)"
	respawn_time(integer) : "Respawn time ( >=1 in seconds)"
	respawn_count(integer) : "Total times to respawn"
	respawn_trig(choices) : "Respawn trigger condition" = [
		 0 : "Default Respawn"
		 1 : "Wait for trigger"
	]
	item_tossvel(integer) : "Velocity to push the item forward and upwards, using the Angle direction"
]
@baseclass = ItemsWorldType [
		angle(choices) : "Random rotation (at map start)" = [
	    "" : "Enabled(def)" 
		1 : "Disabled" 
	]
	skin_override(choices) : "World Type Skin (override)" : 2 = [
		//0 : "Default"
		1 : "Base Green"
		2 : "Medieval Wood"
	]
]
//Patch2 corrections
//_____HEALTH_____
@PointClass base(Items,ItemSize,ItemsWorldType) model(
//ERROR- even though I SET skin_override = 2, the editor acts as if the field is empty,
//so changing spawnflags on the model initially fails.  NOTE: Possible workaround added  
        {{
			//MegaHealth Base
			((spawnflags & 2) != 0 && (skin_override) == 1) -> {"path": "progs/health_100b.mdl"},
        	//Rotten Base
        	((spawnflags & 1) != 0 && (skin_override) == 1) -> {"path": "progs/health_15b.mdl"},
			//Standard Base
			skin_override ==1 -> ":progs/health_25b.mdl",
			//MegaHealth Nedieval
			((spawnflags & 2) != 0 && (skin_override) == 2) -> {"path": "progs/health_100.mdl"},
			((spawnflags & 2) != 0 && (skin_override) == "") -> {"path": "progs/health_100.mdl"},
			//Rotten Nedieval
			((spawnflags & 1) != 0 && (skin_override) == 2) -> {"path": "progs/health_15.mdl"},
			((spawnflags & 1) != 0 && (skin_override) == "") -> {"path": "progs/health_15.mdl"},
																						 //Standard Medieval
																					    "progs/health_25.mdl"
        }}
    ) = item_health : "Health pack" [
	spawnflags(flags) = [
		1 : "Rotten" : 0 : "Only a 15 HP buff"
		2 : "Megahealth" : 0 : "100 HP which counts down"
	]	
	skin_override(choices) : "World Type Skin (override)" : 2 = [
		//0 : "Default"
		1 : "Base Green"
		2 : "Medieval Wood"
	]
	healamount(integer) : "Override heal quantity for pickup (def=15/25/100)"
]
@PointClass base(Items,ItemSize,ItemsWorldType) model("progs/health_5.mdl") = item_healthvial : "Health item giving 2-5 points" [
	healamount(integer) : "Override heal quantity for pickup (def=15/25/100)"
]
//_____AMMO_____
//_____Common Ammo Settings_____
@baseclass color(0 125 200) base(Items,ItemsWorldType,ItemSize) = AmmoBase [
	spawnflags(flags) = [
		1 : "Large box" : 0
	]
	aflag(integer) : "Override ammo quantity for pickup"	
]
//_____SHELLS____
@PointClass base(AmmoBase) model(
	{{
		//large box + base skin 
		skin_override == "1" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_shells1.mdl", "skin": 0 } }},
									  //normal box + base skin 
									  skin_override == "1" -> { "path": "progs/ammo_shells0.mdl", "skin": 0 },
        //large box + medieval skin 
        skin_override == "2" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_shells1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "2" -> { "path": "progs/ammo_shells0.mdl", "skin": 1 },
		//First placement workaround 
        skin_override == "" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_shells1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "" -> { "path": "progs/ammo_shells0.mdl", "skin": 1 }							    
	}}   
    ) = item_shells : "Shells" [
	spawnflags(flags) = [ 2 : "Lid" : 0 ]
	frame_box(choices) : "Lid Placement (set spawnflag)" : : "For exact Lid placement, Random rotation(angle) must be 1, disabled. Descriptions are editor view Top (x/y) standing behind." = [
		-1 : "Randomized"
		0 : "Normal"
		1 : "On Top"
		2 : "Front (leaning closed)"
		5 : "Front (leaning open)"
		3 : "Back (leaning open)"
		4 : "Back (leaning closed)"
		6 : "Right (leaning closed)"
		7 : "Left (leaning open)"	
	]
]
//_____NAILS_____
@PointClass base(AmmoBase) model(

        {{    
		   //large box + base skin 
		   skin_override == "1" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_nails1.mdl", "skin": 0 } }},
										  //normal box + base skin 
										  skin_override == "1" -> { "path": "progs/ammo_nails0.mdl", "skin": 0 },
			//large box + medieval skin 
			skin_override == "2" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_nails1.mdl", "skin": 1 } }},
											//normal box + medieval skin
											skin_override == "2" -> { "path": "progs/ammo_nails0.mdl", "skin": 1 },
			//First placement workaround
			skin_override == "" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_nails1.mdl", "skin": 1 } }},
											//normal box + medieval skin
											skin_override == "" -> { "path": "progs/ammo_nails0.mdl", "skin": 1 }
		}}
        
    ) = item_spikes : "Nails" [
	spawnflags(flags) = [ 2 : "Lid" : 0 ]
	frame_box(choices) : "Lid Placement (set 'Lid' spawnflag)" = [
		-1 : "Randomized"
		0 : "Normal"
		1 : "On Top"
		2 : "Front (leaning closed)"
		5 : "Front (leaning open)"
		3 : "Back (leaning open)"
		4 : "Back (leaning closed)"
		6 : "Right (leaning closed)"
		7 : "Left (leaning open)"	
	]	
]
//_____ROCKETS_____
@PointClass base(AmmoBase) model(

        {{     
       //large box + base skin 
       skin_override == "1" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_rockets1.mdl", "skin": 0 } }},
									  //normal box + base skin 
									  skin_override == "1" -> { "path": "progs/ammo_rockets0.mdl", "skin": 0 },
        //large box + medieval skin 
        skin_override == "2" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_rockets1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "2" -> { "path": "progs/ammo_rockets0.mdl", "skin": 1 },
		//First placement workaround 							    
		skin_override == "" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_rockets1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "" -> { "path": "progs/ammo_rockets0.mdl", "skin": 1 }						    
        }}
        
    ) = item_rockets : "Rockets" [
		frame_box(choices) : "Rockets outside the box" = [
		-1 : "Randomized"
		0 : "Normal"
		1 : "One inside, one outside sideways"
		2 : "Both outside, one sideways"
		3 : "One inside, one outside"
		4 : "Both outside"
		5 : "One inside, one outside leaning"
		6 : "Both outside, one sideways"
		7 : "Both outside, one sideways"	
	]	
]
//_____CELLS_____
@PointClass base(AmmoBase) model(

        {{     
       //large box + base skin 
       skin_override == "1" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_battery1.mdl", "skin": 0 } }},
									  //normal box + base skin 
									  skin_override == "1" -> { "path": "progs/ammo_battery0.mdl", "skin": 0 },
        //large box + medieval skin 
        skin_override == "2" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_battery1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "2" -> { "path": "progs/ammo_battery0.mdl", "skin": 1 },
		//First placement workaround 							    
		skin_override == "" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_battery1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "" -> { "path": "progs/ammo_battery0.mdl", "skin": 1 }						    
        }}
        
    ) = item_cells : "Cells" []
//_____PLASMA_____
@PointClass base(AmmoBase) model(

        {{     
       //large box + base skin 
       skin_override == "1" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_cells1.mdl", "skin": 0 } }},
									  //normal box + base skin 
									  skin_override == "1" -> { "path": "progs/ammo_cells0.mdl", "skin": 0 },
        //large box + medieval skin 
        skin_override == "2" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_cells1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "2" -> { "path": "progs/ammo_cells0.mdl", "skin": 1 },
		//First placement workaround 							    
		skin_override == "" ->  {{ spawnflags & 1 -> { "path": "progs/ammo_cells1.mdl", "skin": 1 } }},
										//normal box + medieval skin
									    skin_override == "" -> { "path": "progs/ammo_cells0.mdl", "skin": 1 }						    
        }}
        
    ) = item_plasma : "Cells (Alt)" [
	frame_box(choices) : "Cartridges outside the box" = [
		-1 : "Randomized"
		0 : "Normal"
		1 : "One inside, one outside sideways"
		2 : "Both outside, one sideways"
		3 : "One inside, one outside"
		4 : "Both outside"
		5 : "One inside, one outside leaning"
		6 : "Both outside, one sideways"
		7 : "Both outside, one sideways"
	]
]
//_____ARMOUR_____
@PointClass base(Items,ArmourSize) model({
		"path" : "progs/armour.mdl",
		"skin" : 0
	}) = item_armor1 : "100% armor (Green)" [
	armortype(integer) : "Override Percentage armor reduction (GRN=0.3,YEL=0.6,RED=0.8)"
	armorvalue(integer) : "Override Quantity armor to pickup (GRN=100,YEL=150,RED=200)"
	]
@PointClass base(Items,ArmourSize) model({
		"path" : "progs/armour.mdl",
		"skin" : 1
	}) = item_armor2 : "150% armor (Yellow)" [
	armortype(integer) : "Override Percentage armor reduction (GRN=0.3,YEL=0.6,RED=0.8)"
	armorvalue(integer) : "Override Quantity armor to pickup (GRN=100,YEL=150,RED=200)"
	]
@PointClass base(Items,ArmourSize) model({
		"path" : "progs/armour.mdl",
		"skin" : 2
	}) = item_armorInv : "200% armor (Red)" [
	armortype(integer) : "Override Percentage armor reduction (GRN=0.3,YEL=0.6,RED=0.8)"
	armorvalue(integer) : "Override Quantity armor to pickup (GRN=100,YEL=150,RED=200)"
	]
//_____KEYS_____
@PointClass base(Items,KeySize) model({"path": "progs/key_medieval.mdl", "skin": 2}) = item_key1 : "Silver key" [
	worldtype(choices) : "Override model type" = [0 : "Use worldspawn" 1 : "Runic" 2 : "Base" 3 : "medieval"]
	netname(string) : "Override the name of the pickup"
	]
@PointClass base(Items,KeySize) model({"path": "progs/key_medieval.mdl", "skin": 6}) = item_key2 : "Gold key" [
	worldtype(choices) : "Override model type" = [0 : "Use worldspawn" 1 : "Runic" 2 : "Base" 3 : "medieval"]
	netname(string) : "Override the name of the pickup"
	]
@PointClass base(Items,KeySize) model({"path": mdl, "skin": skin}) = item_keyx : "Custom key" [
	spawnflags(Flags) = [
		1 : "Custom Key 1" : 0
		2 : "Custom Key 2" : 0
		4 : "Custom Key 3" : 0
		8 : "Custom Key 4" : 0
	]
	mdl(string) : "Model to load/display (progs/key_medieval.mdl)"
	netname(string) : "XXX Part of pickup string 'You got the XXX'"
	message2(choices) : "Particle Style" = [
		"KEYGOLD" : "KEYGOLD - Yellow"
		"KEYSILVER" : "KEYSILVER - Blue"
		"KEYRED" : "KEYRED - Red"
		"KEYGREEN" : "KEYGREEN - Green"
		"KEYPURPLE" : "KEYPURPLE - Purple"
		"KEYWHITE" : "KEYWHITE - White"
	]
]
//_____CUSTOM_____
@PointClass base(Items,KeySize) model({"path": mdl, "skin": skin}) = item_custom : "Custom Pickup Item" [
	mdl(sttring) : "Model Selection (progs/model.mdl)"
	netname(string) : "XXX Part of pickup string 'You got the XXX'"
	noise(sound) : "Pickup Sound (def=weapons/lock4.wav)"
	pos1(string) : "Pickup bounding box minimum (def=-16 -16 -24)"
	pos2(string) : "Pickup bounding box maximum (def=16 16 32)"
	bodyfadeaway(integer) : "Model will fade away on pickup"
	part_active(choices) : "Particle Pickup Setup" = [
		0 : "Not Active"
		1 : "Active"
	]
	part_ofs(string) : "Particle Origin Offset"
	part_tcount(integer) : "Particle Quantity (def=20)"
	part_life(integer) : "Particle Life time (def=2s)"
	part_style(choices) : "Particle Colour" = [
		0 : "Default - White"
		1 : "Yellow"
		2 : "Green"
		3 : "Red"
		4 : "Blue"
		5 : "Purple"
		6 : "Fire"
		7 : "White"
	]
	part_movetype(choices) : "Particle Movement" = [
		0 : "Default - Center"
		2 : "Center"
		3 : "Up"
		4 : "Shockwave"
		5 : "Skull"
		6 : "Lost"
		7 : "Minotaur"
	]	
]
//_____SIGIL_____
@PointClass base(Items,KeySize) model({{
	spawnflags & 1 -> 	"progs/key_rune1.mdl",
	spawnflags & 2 -> 	"progs/key_rune2.mdl",
	spawnflags & 4 -> 	"progs/key_rune3.mdl",
	spawnflags & 8 -> 	"progs/key_rune4.mdl",
									"progs/key_rune1.mdl"
}}) = item_sigil : "Sigil" [
	spawnflags(Flags) = [
		1 : "Episode 1" : 0
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]
@baseclass = PowerTimer [ cnt(integer) : "Duration override (def=30)" ]
//_____ENVIRO SUIT_____
@PointClass base(Items,PowerupSize,PowerTimer) model({{
	exactskin == 0 -> 	{"path":"progs/artifact_envsuit.mdl"},
	exactskin == 1 -> 	{"path":"progs/artifact_envsuit.mdl", "skin": 1},
	exactskin == 2 -> 	{"path":"progs/artifact_envsuit.mdl", "skin": 2},
	exactskin == 3 -> 	{"path":"progs/artifact_envsuit.mdl", "skin": 3},
	exactskin == 4 -> 	{"path":"progs/artifact_envsuit.mdl", "skin": 4},
									 "progs/artifact_envsuit.mdl"
}}) = item_artifact_envirosuit : "Environmental Protection Suit" [
	exactskin(choices) : "Skin Selection" = [
		0 : "Default"
		1 : "Green"
		2 : "Brown"
		3 : "Aqua"
		4 : "Blue"
	]
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
//Patch2 addition
//_____AIR TANK_____
@PointClass base(Items,PowerupSize,PowerTimer) model({{
	exactskin == 0 -> 	{"path":"progs/artifact_airtank.mdl"},
	exactskin == 1 -> 	{"path":"progs/artifact_airtank.mdl", "skin": 1},
	exactskin == 2 -> 	{"path":"progs/artifact_airtank.mdl", "skin": 2},
	exactskin == 3 -> 	{"path":"progs/artifact_airtank.mdl", "skin": 3},
	exactskin == 4 -> 	{"path":"progs/artifact_airtank.mdl", "skin": 4},
									 "progs/artifact_airtank.mdl"
}}) = item_artifact_airtank : "Air tank, Permanent Upgrade! Primary : Player takes no damage from drowning. Secondary : Reduces Poisonous debuff by 50% and can surive LG/PG firing underwater." [
    spawnflags(Flags) = [
		8 : "Silent" : 0
	]
    targetname(target_source) : "Name" : : "Toggleable, use trigger ent for exact state."
	exactskin(integer) : "Skin Selection"
	cnt(integer) : "Duration" : : "Override default duration of artifact (default = infinite)"
	noise(sound) : "Custom sound (pickup)"
	volume(integer) : "Volume (Max range(def=1, no sound=-1)"
	distance(choices) : "Breathing sound outside water or not" = [
	    0 : "All the time"
		1 : "Only in water (default)"
		]
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
//_____JUMP BOOTS_____
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_jumpboots.mdl") = item_artifact_jumpboots : "Jump Boots, Permanent upgrade! Primary : Player can do (1-4) extra jumps. Secondary : Can jump while falling off ledges or midair." [
	noise(sound) : "Custom Sound (pickup)"
	cnt(integer) : "Duration" : : "Override default duration of artifact (default = infinite)"
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
	count(choices) : "Power level override" = [ 
	   -1 : "Endless"
		0 : "Default(1)"
		2 : "2 Jumps" 
		3 : "3 Jumps"
		4 : "4 Jumps"
	]
]
//_____LAVA SHIELD_____
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_lavashield.mdl") = item_artifact_lavashield : "Lava Shield, Permanent upgrade! Primary : Player takes no HP/armour damage from lava. Secondary : Flame and lava attack damage is reduced (Chthon, Drole, Gargoyle, Quoth Dguard)." [
	cnt(integer) : "Duration" : : "Override default duration of artifact (default = infinite)"
	noise(sound) : "Custom Sound (pickup)"
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
	volume(integer) : "Volume (Max range (def=1, no sound=-1)"
]
//_____BLAST BELT_____
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_blastbelt.mdl") = item_artifact_blastbelt : "Blast Belt, Permanent upgrade! Primary : Player does not take splash damage, but take direct damage. Secondary : Immune to floor impact attacks (hammer ogre, golems etc)" [
	cnt(integer) : "Duration" : : "Override default duration of artifact (default = infinite)"
	noise(sound) : "Custom Sound (pickup)"
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_pent.mdl") = item_artifact_invulnerability : "Pentagram of Protection" [
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_invis.mdl") = item_artifact_invisibility : "Ring of Shadows" [
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_quad.mdl") = item_artifact_super_damage : "Quad damage" [
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_tome.mdl") = item_artifact_tomeofpower : "Tome of Power" [
	worldtype(choices) : "Override model type" = [0 : "Use worldspawn" 1 : "Runic" 2 : "Base" 3 : "medieval"]
	netname(string) : "Override the name of the pickup"
	]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_piercer.mdl") = item_artifact_nail_piercer : "Nail Piercer" [
	mdl(string) : "Override the model used"
	netname(string) : "Override name of pickup"
]
@PointClass base(Items,PowerupSize,PowerTimer) model("progs/artifact_sharp.mdl") = item_artifact_sharp_shooter : "Sharp Shooter" []
//_____item_backpack Settings_____
@baseclass  = BackPackSettings [
    count(integer) : "Amount of (random) ammo to give"
	ammo_shells(integer) : "Exact amount of shells"
	ammo_nails(integer) : "Exact amount of spikes"
	ammo_rockets(integer) : "Exact amount of rockets"
	ammo_cells(integer) : "Exact amount of cells"
	
	exactskin(choices) : "Skin Selection" = [
		0 : "Original brown"
		1 : "Green"
		2 : "Blue"
		3 : "Red"
		4 : "Yellow"
		5 : "Swampy"
		6 : "White"
		7 : "Pale"
	]
]
//_____BACK PACK_____
@PointClass base(targetname,BackPackSettings,Items,PowerupSize) model({{
	exactskin == 0 -> 	{"path":"progs/w_backpack.mdl"},
	exactskin == 1 -> 	{"path":"progs/w_backpack.mdl", "skin": 1},
	exactskin == 2 -> 	{"path":"progs/w_backpack.mdl", "skin": 2},
	exactskin == 3 -> 	{"path":"progs/w_backpack.mdl", "skin": 3},
	exactskin == 4 -> 	{"path":"progs/w_backpack.mdl", "skin": 4},
	exactskin == 5 -> 	{"path":"progs/w_backpack.mdl", "skin": 5},
	exactskin == 6 -> 	{"path":"progs/w_backpack.mdl", "skin": 6},
	exactskin == 7 -> 	{"path":"progs/w_backpack.mdl", "skin": 7},
									 "progs/w_backpack.mdl"
	}}) = item_backpack : "Backpack with random/exact amounts of ammo." [
	spawnflags(Flags) = [
		1 : "Shells" : 0
		2 : "Nails" : 0
		4 : "Rockets" : 0
		8 : "Cells" : 0
	]	
]
//_____item_backpack_armour Settings_____
@baseclass  = BackPackArmourSettings [
    armorvalue(integer) : "Armour Amount - override def(15)/30/45) "
]
//_____BACK PACK ARMOR_____
@PointClass base(targetname,BackPackArmourSettings,Items,PowerupSize) model("progs/w_backpack.mdl") = item_backpack_armour : "Backpack with exact amounts of armor" [
	spawnflags(Flags) = [
		1 : "Green Armor" : 0
		2 : "Yellow Armor" : 0
		4 : "Red Armor" : 0
	]	
]
//_____ITEM PROGRESSION SPAWNER_____
@PointClass size(-16 -16 0, 16 16 32) base(AppearFlags) color(0 0 200) = item_progspawn : "Spawn location for progression list, use with a list of items, ammo, weapons, with the progspawnlist key and targeting each other" [
	spawnflags(Flags) = [
		32 : "No Tele FX" : 0 : "No tele FX effect when changing item at spawn marker"
	]	
	targetname(target_source) : "Must exist and be the same for all markers in same list"
	target(target_destination) : "Must point to the first item in the progresion list"
	target2(target_destination) : "Targets to fire when the spawn marker is used"
	message(string) : "message to display when triggered"
]
	
//======================================================================
//
// WEAPON entities
//
//======================================================================

//_____Common weapon settings_____
@baseclass size(-16 -16 0, 16 16 56) color(0 0 200) base(AppearFlags, targetname) = Weapon [
	spawnflags(Flags) = [
		16 : "Respawn" : 0 : "Can respawn after being picked up"
		32 : "Floating" : 0 : "Spawns floating, trigger entity to drop it"
		64 : "Start OFF" : 0 : "Starts off and waits for trigger to spawn"
		128 : "No Particles" : 0 : "No particle or effects active on this entity"
	]
	message(string) : "Message when picked up"
	respawn_time(integer) : "Respawn time ( >=1 in seconds)"
	respawn_count(integer) : "Total times to respawn"
	respawn_trig(choices) : "respawn trigger condition" = [
		 0 : "Default Respawn"
		 1 : "Wait for trigger"
	]
	progspawnlist(choices) : "Part of an item progression list, use in conjunction with item_progspawn, and target/targetname items in the list" = [
		0 : "Default, not part of a list"
		1 : "Part of an item progression list"
	]
	aflag(integer) : "Override ammo quantity for pickup"
	netname(string) : "Override name of the weapon"
]
//----------------------------------------------------------------------
@PointClass base(Weapon) model("progs/g_shot2.mdl") = weapon_supershotgun : "Super shotgun" []
@PointClass base(Weapon) model("progs/g_nail.mdl") = weapon_nailgun : "Nailgun" []
@PointClass base(Weapon) model("progs/g_nail2.mdl") = weapon_supernailgun : "Perforator" []
@PointClass base(Weapon) model("progs/g_rock.mdl") = weapon_grenadelauncher : "Grenade launcher" []
@PointClass base(Weapon) model("progs/g_rock2.mdl") = weapon_rocketlauncher : "Rocket launcher" []
@PointClass base(Weapon) model("progs/g_light.mdl") = weapon_lightning : "Thunderbolt" []

@PointClass base(Weapon) model("progs/g_shot1.mdl") = weapon_shotgun : "Sawn-off Shotgun" []
@PointClass base(Weapon) model("progs/g_axe.mdl") = weapon_axe : "Quake Axe" []
@PointClass base(Weapon) model("progs/g_shadaxe.mdl") = weapon_upgrade_axe : "Shadow Axe" []
@PointClass base(Weapon) model("progs/g_shot3.mdl") = weapon_upgrade_ssg : "Widowmaker Shotgun" []
@PointClass base(Weapon) model("progs/g_plasma.mdl") = weapon_upgrade_lg : "Plasma Gun" []

//======================================================================
//
// FUNCTIONS
//
//======================================================================

//______baseclass for common BModel func_  entities_____
@baseclass base(AppearFlags,targetname,target) = FuncItems [
	spawnflags(Flags) = [
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]	
]
//_____baseclass for BModel lighting options_____
@baseclass = FuncLighting [
//Patch2 addition	
	alpha(integer) : "Transparency (0 -> 1, ex: .5)" : : "Make the brush(Bmodel) transparent, 0 is completely hidden. NOTE - does not work on func_detail_illusionary/func_detail_wall."	

 //----- Lighting Options -----
	
	_minlight(integer) : "Min Light" :  : "Set the minimum light level for every surface of a brush model(BModel). A very useful feature for BModels to make them fit more 'naturally' into their surroundings. Especially where often times light can leave compeletely unlit(black) faces due to their nature(non-static w/hidden faces)."
	_minlight_color(color255) : "Min Light color" :  : "Specify RGB component values for the color of the  minlight. Values are between 0 and 255 (between 0 and 1 is also accepted). Default is white(ex 255 255 255)."
	_lightignore(choices) : "Min Light ONLY" :  : "Set a BModel to receive minlight only, ignoring all other forms of lighting. Could be useful on rotators / trains." = [
	   	0 : "OFF(def)"
		1 : "Ignore ALL(Entity/Sun) lighting"
	]
	_minlight_exclude(string) : "Min light exclude (texture name)" :  : "Faces with the given texture name are excluded from receiving minlight on this brush model."
		
//----- Shadows/Shading -----
	 	
	_shadow(choices) : "Shadows" : : "Set to 1, this model will cast shadows on the world, other BModels and itself. The use of '_shadow' intrinsically implies '_shadowself'. Set -1 on 'func_detail' and 'func_group' to prevent them from casting shadows. Default 0. NOTE - Shadows are STATIC and do NOT move with moving BModels." = [
	   -1 : "Disable func_detail / func_group)" 
	    0 : "Default"
		1 : "Cast shadows"
	]
	_shadowself(choices) : "Self Shadow" :  : "Set to 1, this model will cast shadows on itself if one part of the model blocks the light from another model surface. This can be a better compromise for moving models than full shadowing. Default 0." = [
		0 : "OFF(def)"
		1 : "Cast Shadows on Self"
	]	
	_shadowworldonly(choices) : "Shadow World Only" :  : "Set to 1 this model will cast shadows on the world only, not other BModels. If you are having problems with BModels shadowing each other, this setting sometimes helps to alleviate that." = [
		0 : "OFF(def)"
		1 : "Do NOT Shadow other BModels"
	]	
	_phong(choices) : "Phong Shading" :  : "1 enables phong shading on this model with a default '_phong_angle' of 89 degrees. Simply put, phong shading attempts to hide the 'hard' edges on rounded bruskwork to give the appearance of a smooth rounded surface. For instance, pipes, columns etc."  = [
	    0 : "OFF(def)"
		1 : "Enabled(Smooth Edges)"
	]
	_phong_angle(integer) : "Phong Angle (override, def=89)" :  : "Enter a custom angle for phong shading calculations. Adjacent faces with normals 'x' many degrees apart, or less will, be smoothed. Consider setting '_anglescale' to '1' on lights or in worldspawn to make the effect of phong shading more visible." 
	_phong_angle_concave(integer) : "Phong Angle Concave" : : "Optional key for setting a different angle threshold for 'concave' joints. If its 0 or unset, the same value as '_phong_angle' is used."
	_dirt(choices) : "Dirt Mapping (override)" :  : "-1 disables dirtmapping on the brush model. Useful if the BModel touches or sticks into the world, and you want to keep those areas from turning black. Default 0." = [
	     0 : "Do Nothing"
	    -1 : "Disable Dirt Mapping"
	]		
]
//_____func_button Settings_____
@baseclass = FuncButtonSettings [
	message(string) : "Message"
	health(integer) : "Health (shootable)"
	lip(integer) : "Lip (def=4)"
	angle(integer) : "Direction" :  : "Determines the move direction, use 360 for angle 0)"
	speed(integer) : "Speed (def=40)"
	wait(integer) : "Delay before reset (def=1)"
	delay(integer) : "Delay before trigger"
	estate(choices) : "Override (starting entity state)" = [
	    1 : "ON" 
	    2 : "OFF"
	    4 : "DISABLE"
    ]
	sounds(choices) : "Sounds" = [
		0 : "Steam metal"
		1 : "Wooden clunk"
		2 : "Metallic clink"
		3 : "In-out"
		4 : "Silent"
		5 : "Custom"
	]
	noise(sound) : "Custom sound - 1st move"
	noise1(sound) : "Custom sound - 2nd move"
	teledest(integer) : "Unique number for multiple teleporter destinations"
]
//_____BUTTON_____
@SolidClass base(FuncItems, FuncButtonSettings, FuncLighting) = func_button : "Button (bmodel) with two states" [
	spawnflags(flags) = [ 32: "Start Disabled" : 0 ]
	angletarget(target_destination) : "Entity (path_corner) to move towards (custom direction)"
	yaw_speed(integer) : "Return movement speed (def=speed)"
	height(integer) : "Exact distance to move (works like func_plat and uses angles)"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____func_door Settings_____
@baseclass = FuncDoorSettings [
	message(string) : "Message if triggered"
	health(integer) : "Health (shootable)"
    angle(integer) : "Direction" :  : "Determines the move direction, use 360 for angle 0)"
    speed(integer) : "Speed (def=100)"
	yaw_speed(integer) : "Speed (returning)" 
	wait(integer) : "Delay before close (def=3, -1 never return)"
	lip(integer) : "Lip (def=8)"
	dmg(integer) : "Damage when blocked (def=2)"
	sounds(choices) : "Sound" = [
		0 : "Silent"
		1 : "Stone"
		2 : "Base"
		3 : "Stone Chain"
		4 : "Screechy Metal"
		5 : "Custom"
		11 : "Base plat"
		12 : "Medieval plat"
	]
	locksounds(choices) : "Sound (locked)" = [
		0 : "talktalk (default)"
		1 : "Short rattle"
		2 : "Medium rattle"
		3 : "Long rattle"
		13 : "Trigger sound"
		14 : "Silent"
		16 : "Secret sound"
		21 : "Base Sound 1"
		22 : "Base Sound 2"
		23 : "Base Sound 3"
		24 : "Base Sound 4"
	]
	noise(sound) : "Custom sound - Locked"
	noise1(sound) : "Custom sound - Moving(Looping)"
	noise2(sound) : "Custom sound - Stopped"
	noise3(sound) : "Custom sound - Key Locked"
	noise4(sound) : "Custom sound - Key open"
	customkey(choices) : "Custom Key" = [
		0 : "Do nothing"
		1 : "Custom Key 1"
		2 : "Custom Key 2"
		3 : "Custom Key 3"
		4 : "Custom Key 4"
	]
	message2(string) : "Custom key message" :  : "Example - 'You need the Custom Key."
	midstart(integer) : "If set to 1, door starts in 2nd position and waits for trigger, then work as spawned"
	height(integer) : "Exact distance to move (works like func_plat and uses angles)"
	persistentkey(integer) : "If set to 1, the key required for this door wil not be removed from player"
	yaw_speed(integer) : "return movement speed (def=speed)"
	bbmins(string) : "Custom size for generated trigger (def='-60 -60 -8')"
	bbmaxs(string) : "Custom size for generated trigger (def='60 60 8')"
	angletarget(target_destination) : "Entity (path_corner) to move towards (custom direction)"
]	
//_____DOOR_____
@SolidClass base(FuncItems, FuncDoorSettings, FuncLighting) = func_door : "Door (bmodel) with two states" [
	spawnflags(flags) = [
		1 : "Start Open" : 0 : "Door opens in reverse state (moved to dest at spawn)"
		2 : "Spawn trigger field" : 0 : "Will spawn trigger around door even if targetname SETUP"
		4 : "Don't link" : 0 : "Touching doors will not link into a single entity"
		8 : "Gold Key" : 0 : "Requires gold key to open"
        16: "Silver Key" : 0 : "Requires silver key to open"
        32: "Toggle" : 0 : "Door waits for trigger between states (if wait=-1 cannot be blocked)"
	]	
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____func_door_secret Settings_____
@baseclass = FuncDoorSecretSettings [
    speed(integer) : "Speed (def=50)"
	yaw_speed(integer) : "Speed (returning)"
	t_width(integer) : "First distance"
	t_length(integer) : "Second distance"
	wait(integer) : "Delay before close (def=5)"
	dmg(integer) : "Damage when blocked (def=2)"
	message(string) : "Message if touched"
	sounds(choices) : "Sound" = [
		1 : "Medieval"
		2 : "Metal"
		3 : "Base (default)"
		4 : "Silent"
		5 : "Custom"
	]
	locksounds(choices) : "Sound (locked)" = [
		0 : "Default talktalk"
		1 : "Short rattle"
		2 : "Medium rattle"
		3 : "Long rattle"
	]
	noise(sound) : "Custom sound - Locked"
	noise1(sound) : "Custom sound - Open"
	noise2(sound) : "Custom sound - Opening"
	noise3(sound) : "Custom sound - Closed"
]
//_____DOOR SECRET_____
@SolidClass base(FuncItems,FuncDoorSecretSettings,FuncLighting) = func_door_secret : "A Door (bmodel) with 2 states and multiple stages" [
	spawnflags(flags) = [
		1 : "Open once only" : 0
		2 : "Moves left first" : 0
		4 : "Moves down first" : 0
		8 : "Not shootable" : 0
       16 : "Always shootable" : 0
	]
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//----- func_plat Settings
@baseclass = FuncPlatSettings [
    speed(integer) : "Speed (def=150)"
	height(integer) : "Distance to move"
	sounds(choices) : "Sound" = [
		1 : "Base (fast)"
		2 : "Medieval (default)"
		4 : "Silent"
		5 : "Custom"
	]
	noise(sound) : "Custom sound - Moving(Looping)"
	noise1(sound) : "Custom sound - Stopped"
]
//_____PLATFORM_____
@SolidClass base(FuncItems,FuncPlatSettings,FuncLighting) = func_plat : "A Platform (bmodel) with 2 states" [	
	spawnflags(Flags) = [
		1 : "Low trigger" : 0
		4 : "Min trigger" : 0
		8 : "Start Lower" : 0
		16 : "Start Open" : 0
        32: "Start Disabled" : 0
	]
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____func_train Settings_____
@baseclass = FuncTrainSettings [
    mdl(string) : "Use a model"
	speed(integer) : "Speed (def=100)"
	dmg(integer) : "block damage (def=2)"
	sounds(choices) : "Sound" = [
		0 : "Silent"
		1 : "Ratchet Metal"
		5 : "Custom"
		11 : "Base plat"
		12 : "Med plat"
	]
	noise(sound) : "Custom sound - Stopped"
	noise1(sound) : "Custom sound - Moving(Looping)"
]
//_____TRAIN____
@SolidClass base(FuncItems, FuncTrainSettings, FuncLighting) = func_train : "Bmodel platform moving around entity chain" [
	spawnflags(Flags) = [
		1 : "Start ON" : 0
		2 : "Non Solid" : 0
		4 : "Use Model" : 0 : "Model with no collision use (mdl) key, def=empty model."
		8 : "Touch damage" : 0
	  32 : "Start Reversed" : 0
	]
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____PATH CORNER____
@PointClass base(AppearFlags) flags(Angle) size(-8 -8 -8, 8 8 8) color(255 128 0) = path_corner : "Path Corner" [
	spawnflags(Flags) = [
		1 : "Exact logic" : 0
		2 : "Instant" : 0
		4 : "Reverse" : 0
		8 : "No Pause" : 0
	]
	targetname(target_source) : "Name of path corner"
	target(target_destination) : "targetname of Forward route"
	target2(target_destination) : "targetname of Alt Forward route"
	targetback(target_destination) : "targetname of Backward route"
	corner_event(target_destination) : "target to trigger when used"
	corner_route(choices) : "Change route logic" = [
		0 : "Do nothing"
		1 : "Forward"
		2 : "Alt Forward"
		3 : "Backward"
		4 : "Exact"
		5 : "Random"
	]
	corner_switch(choices) : "Change reverse state" = [
		-1 : "No"
		 0 : "Do Nothing"
		 1 : "Yes"
		 2 : "Toggle"
	]
	corner_pause(choices) : "Change pause state" = [
		-1 : "No"
		 0 : "Do Nothing"
		 1 : "Yes"
		 2 : "Toggle"
	]
	corner_speed(integer) : "Change speed of target path_corner"
	state(choices) : "Starting route" = [
		0 : "Do Nothing"
		1 : "Forward"
		2 : "Alt Forward"
		3 : "Backward"
	]
	//patch2 addition
	//hey added more stuff
	//* Added corner_pstate event to change monsters passive state when touched
	//New entity key for 'path_corner'
	corner_pstate(choices) : "Change passive state (-1=OFF, 1=ON, 2=TOGGLE)" = [
		1 : "On"
		2 : "Toggle"
	  -1 : "Off"
	]
	wait(integer) : "Wait at corner(Stop=-1)"
	delay(integer) : "Random delay at corner"
	speed(integer) : "Speed between corners (def=100)"
	alpha(integer) : "Visual Arrow (def=0.35)"	
]
//_____EPISODE GATE____
@SolidClass base(FuncItems, FuncLighting) = func_episodegate : "Episode Gate" [
	spawnflags(Flags) = [
		1 : "Episode 1" : 0
		2 : "Episode 2" : 0
		4 : "Episode 3" : 0
		8 : "Episode 4" : 0
	]
]
//_____BOSS GATE_____
@SolidClass base(FuncItems, FuncLighting) = func_bossgate : "Boss gate" []

//_____func_skill Settings_____
@baseclass = FuncSkillSettings [
    target(target_destination) : "target - Particle Emitters"
	target2(target_destination) : "target2 - When touched/damaged"
	style(choices) : "Skill level" = [
		0 : "Easy (default)"
		1 : "Normal"
		2 : "Hard"
		3 : "Nightmare"
	]
	message2(string) : "Alternative touch/damage message"
	health(integer) : "Can be damaged instead of touched"
	angle(integer) : "Direction"
	speed(integer) : "Movement Speed (def=100)"
	lip(integer) : "Lip (def=8)"
	noise1(sound) : "Custom sound : Stopped"
	noise2(sound) : "Custom sound : Moving(Looped)"
	noise3(sound) : "Custom sound : Touch"
]
//_____SKILL SELECT_____
@SolidClass base(FuncItems, FuncSkillSettings, FuncLighting) = func_skill : "This is a special bmodel that changes texture based on current skill/chaos level. Will keep checking skill level until triggered (based on door QC code)" [
	spawnflags(Flags) = [
		1 : "Start Open" : 0
		2 : "Chaos" : 0 : "special setup for the random chaos mode (waitmin=touch delay)"
	]
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
	wait(integer) : "-1 cannot be touched or damaged (visual only)"
	waitmin(integer) : "Chaos mode touch slowdown timer (def=1s)"
	health(integer) : "Can be damaged instead of touched (def=touch)"
]

//_____func_laser Settings_____
@baseclass = FuncLaserSettings [
    message(string) : "Switched off Message"
	message2(string) : "Switched on Message"
	wait(integer) : "-1 = display switched message once"
	dmg(integer) : "Touch damage (1 per 0.1s)"
	alpha(integer) : "Alpha variance (def 0.5)"
	spr_frame(choices) : "Particle Type" = [
		0  : "Nothing"
		1  : "Yellow"
		2  : "Green"
		4  : "Red"
		8  : "Blue"
		16 : "Purple"
		32 : "Fire"
		64 : "White"
	]
	angle(integer) : "Movement of particles (def=-2 down)"
	part_limit(integer) : "Maximum active particles (def=25)"
	part_life(integer) : "Lifetime of particle (def=2s)"
	part_velrand(string) : "Random movement of particles (def='4 4 4')"
	part_vol(string) : "Size of area for particles (def=bmodel)"
	wakeup_dist(integer) : "Distance to wakeup particles (def=768)"
	spawn_base(integer) : "Min time spawn particles (def=0.1s)"
	spawn_rand(integer) : "Random amount spawn particles (def=0.1s)"
	sounds(choices) : "Sounds" = [
		0 : "Silent"
		1 : "Laser"
		2 : "Power"
		5 : "Custom"
	]
	noise1(sound) : "Custom sound : Switch ON"
	noise2(sound) : "Custom sound : Switch OFF"
]
//_____LASER_____
@SolidClass base(FuncItems, FuncLaserSettings, FuncLighting) = func_laser : "A togglable laser, hurts to touch, can be used to block players." [
	spawnflags(Flags) = [
		2 : "Solid" : 0
		4 : "No Damage" : 0
	]
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____func_bob Settings_____
@baseclass = FuncBobSettings [
    height(integer) : "Intensity (def=4)"
	count(integer) : "Cycle timer (def=2, min=1)"
	waitmin(integer) : "Speed up scale (def=1)"
	waitmin2(integer) : "Slow down scale (def=0.75)"
	delay(integer) : "Delay start (-1=random)"
]
//_____BOB_____
@SolidClass base(FuncItems, FuncBobSettings, FuncLighting) = func_bob : "Bobbing Bmodel" [	
	spawnflags(Flags) = [
		4 : "NonSolid" : 0
	]	
]	
//_____func_explobox Settings_____
@baseclass = ExploboxSettings [
    noise(sound) : "Custom Sound - Explosion"
	health(integer) : "Health (def=15)"
	dmg(integer) : "Radius Damage (def=160)"
]
//_____EXPLODING BOX_____
@SolidClass base(FuncItems,ExploboxSettings,FuncLighting) = func_explobox : "Exploding Brushwork" []
//NOTE- These two directly below still need sorted out
//_____func_pressureswitch Settings_____
@baseclass = PSwitchSettings [
	message(string) : "Message" :  : "Message to display when triggered"
	speed(integer)  : "Move Speed (def=40)"
	lip(integer) : "Lip (def 4)" :  : "Lip remaining at end of move. (def=4)"
	//wait(integer) : "Wait (-1 = display message and fire target(s) only once)"
	//angle(integer) : "Direction" :  : "Always moves downward (needs to reflect gravity pressure)"
	sounds(choices) : "Sound Style" = [
		0 : "Steam Metal" 
		1 : "Wooden" 
		2 : "Metallic" 
		3 : "In-out" 
		4 : "Silent" 
		5 : "Custom"
	]
	noise(sound) : "Custom Sound (1st movement)"
	noise1(sound) : "Custom Sound (2nd movement)" : : "(default = noise wav file)"	
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____PRESSURE SWITCH_____
@SolidClass base(FuncItems,PSwitchSettings,FuncLighting) = func_pressureswitch : "Pressure Switch - NOTE - To be used in conjunction with 'func_insidevolume' and 'trigger_doorstate'." []
//_____INSIDE VOLUME_____
@SolidClass base(AppearFlags) = func_insidevolume : "Function to test if an entity bounding box is inside of this volume." [
	spawnflags(flags) = [
		1 : "Payer" : 0 : "Will react to Player(s)"
	    2 : "Monster" : 0 : "Will react to Monster(s)"
	    4 : "Item" : 0 : "Will react to item(s)"
		8 : "Pushable" : 0 : "Will react to pushable(s)"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	targetname(target_source) : "Name" :  : "Works with entity state system."
	target(target_destination) : "Target (fully inside)" :  : "Name of target(s) to trigger when something is FULLY INSIDE the volume (fires every 0.1s)."
	target2(target_destination) : "Target2 (partly inside)" :  : "Name of target(s) to trigger when something is PARTIALLY INSIDE the volume (fires every 0.1s)."
	message(target_destination) : "Target3 (volume exit)" :  : "Name of target(s) to trigger when exiting the VOLUME(fires on exit only)."
	wait(choices) : "Wait" :  : "-1 = Fire the FULLY INSIDE/EXIT volume targets once." = [
		0 : "Default"
	   -1 : "Only ONCE"
	]
	delay(integer) : "Delay" :  : "Time before the volume controller becomes active."
	message2(target_destination) : "Triggered ONLY by -" :  : "Name of the only entity that can interact with this volume."
	no_deadbody(choices) : "Corpse Activate" :  : "1 = Monster dead bodies will not trigger." = [
		0 : "Enabled(def)"
		1 : "Disabled"
	]
]
//Patch2 addition | ON HOLD| light.exe issue, crashes if bouce lighting is enabled in worldspawn
//_____FUNC SHADOW_____
@SolidClass base(AppearFlags,targetname,target) = func_shadow : "An Invisible bmodel that casts shadows." [
	spawnflags(flags) = [
	    2 : "Fading" : 0 : "Will gradually fade over time (speed)"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	state(choices) : "Intended state to operate with (0=CLOSED, 1=OPEN)" = [
		0 : "Closed"
		1 : "Open"	
	]
	speed(integer) : "Fade in/out timer for the shadow (def=1s)"
	_switchableshadow(choices) : "Toggle Shadow (MUST be 1)" : 1 : "ADVANCED - Set to 1, this BModel casts a shadow that can be switched on/off using QuakeC. To make this work, a lightstyle is automatically assigned and stored in a key called 'switchshadstyle', which the QuakeC will need to read and call the 'lightstyle() builtin' with an 'a' or 'm' to switch the shadow on or off. BModels sharing the same targetname, and with '_switchableshadow' set to 1, will share the same lightstyle." = [
		0 : "Do Nothing"
		1 : "Enabled"
	]
	_shadow(choices) : "Shadows (MUST be 1)" : 1 : "Set to 1, this model will cast shadows on the world, other BModels and itself. The use of '_shadow' intrinsically implies '_shadowself'. Set -1 on 'func_detail' and 'func_group' to prevent them from casting shadows. Default 0. NOTE - Shadows are STATIC and do NOT move with moving BModels." = [
	   -1 : "Disable func_detail / func_group)" 
	    0 : "Default"
		1 : "Cast shadows"
	]
	_dirt(choices) : "Dirt Mapping (override)" :  : "-1 disables dirtmapping on the brush model. Useful if the BModel touches or sticks into the world, and you want to keep those areas from turning black. Default 0." = [
	     0 : "Do Nothing"
	    -1 : "Disable Dirt Mapping"
	]	
]

//======================================================================
//
// TRIGGERS
//
//======================================================================

@baseclass = TrigSound [
	sounds(choices) : "Sound style" = [
		0 : "Default"
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"
	]
	noise(sound) : "Custom Sound (triggered)"
]
//_____Common Trigger Settings_____
@baseclass = TrigCommon [
    health(integer) : "Health"
    message(string) : "Message when triggered"
    angle(integer) : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."
	delay(integer) : "Delay before trigger"
	wait(integer) : "Wait (time before re-triggering)"
	killtarget(string) : "Kill target" : : "Use trigger_entitystate_off instead!"
]
@baseclass base(AppearFlags, targetname, target, TrigCommon, TrigSound)	color(128 0 128) = TrigBasic [
	spawnflags(flags) = [ 
		1 : "No Touch" : 0
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
]
//_____TRIGGER ONCE_____
@SolidClass base(TrigBasic) = trigger_once : "Trigger ONCE" [
	spawnflags(flags) = [
	    1 : "No Touch" : 0
	    4 : "DEVMODE" : 0
		8 : "In View" : 0
		16: "MOD Check" : 0
		32: "Monsters" : 0
	]
	t_length(integer) : "Inview Distance"
	teledest(integer) : "Unique number for multiple teleporter destinations"
]
//_____TRIGGER MULTIPLE_____
@SolidClass base(TrigBasic) = trigger_multiple : "Trigger MULTIPLE" [
	spawnflags(flags) = [ 
	     1 : "No Touch" : 0
	     4 : "DEVMODE" : 0
		16 : "MOD Check" : 0
		32 : "Monsters" : 0
	]
	wait(choices) : "Wait before reset" = [
		-1 : "Never reset"
		 2 : "2 seconds"
		 4 : "4 seconds(def)"
	]
	teledest(integer) : "Unique number for multiple teleporter destinations"
	count(integer) : "If over 0, will be the number of time it can fire before switching off"
]
//_____TRIGGER SECRET_____
@SolidClass base(TrigBasic) = trigger_secret : "Trigger Secret" [
	spawnflags(flags) = [ 2: "Remove/Block Message" : 0 ]
]
//Patch2 addition
//----- Trigger Relay Settings_____
@baseclass size(-8 -8 -8, 8 8 8) color(128 0 128) iconsprite("sprites/trigger_relay2.spr")= TriggerRelaySettings [
    message(string) : "Message (on trigger)"
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	delay(integer) : "Delay before firing"
	cnt(integer) : "Random Time to add to delay"
	waitmin(integer) : "% random chance between target/target2(0.1->1.0)"
	state(integer) : "toggle/repeat starting cycle = 1 (def) or 2"
	sounds(choices) : "Sound style" = [
		0 : "Default"
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"
	]
	noise(sound) : "Custom Sound (triggered)"
	noise1(sound)  : "CustSnd (Repeat spawnflags OFF event)" :  : "Custom sound for repeat spawnflags OFF event"
	noise2 (sound) : "CustSnd (Repeat spawnflags ON event)" :  : "Custom sound for repeat spawnflags ON event"
	wait2(integer) : "Repeat OFF event, time to wait" 
    delay2(integer) : "Repeat OFF event, random amount of time"
	volume(choices) : "Volume" :  : "volume of sound (0.1->1,(def=1)" = [
		1.0 : "Full Volume(def)"
		0.9 : "0.9"
		0.8 : "0.8"	
		0.7 : "0.7"	
		0.6 : "0.6"
		0.5 : "0.5"
		0.4 : "0.4"
		0.3 : "0.3"
		0.2 : "0.2"										
		0.1 : "Barely Audible"
	]
	teledest(integer) : "Unique number for multiple teleporter destinations"
]
//_____TRIGGER RELAY_____
@PointClass base(AppearFlags, targetname, target, target2, TriggerRelaySettings) = trigger_relay : "Triggers target(s) with custom sounds and messages. NOTE: this trigger cannot be touched. It can only be fired by other triggers/events. Can contain killtargets, targets, delays, and messages." [
	spawnflags(flags) = [ 
	    2 : "Random" : 0 : "Will randomly select between target/target2"
	    4: "Toggle" : 0 : "Will toggle between the target/target2"
	    8  : "Repeat" : 0 : "Will keep re-triggering targets (fire use to toggle on/off) Uses wait + delay for amount of time between re-trigger events" 
	    32 : "Start Disabled" : 0 : "Will start disabled, will req trigger_entitystate_on to enable"
	]	
]

//REPEAT : Will keep re-triggering targets (fire targetname to stop/start)
 //        endstate : Final state when re-trigger stops
   //      state ON trigger event = target
     //    state ON time = wait + (delay x random())
     //    state ON custom sound = noise1
      //   state OFF trigger event = target2
      //   state OFF time = wait2 + (delay2 x random())
        // state OFF custom sound = noise2
        
//_____Trigger Counter Settings_____
@baseclass = TriggerCounterSettings [
	message2(string) : "Final Message (cannot be blocked)."
	count(integer) : "Count before firing."
	delay(integer) : "Delay before trigger."
]
//_____TRIGGER COUNTER_____
@PointClass base(AppearFlags, targetname, target, TriggerCounterSettings, TrigSound) color(128 0 25)
	size(-8 -8 -8, 8 8 8) = trigger_counter : "Trigger counter" [
	spawnflags(flags) = [ 
	    1 : "No Messages" : 0
	   16 : "Display Countdown" : 0  
	    32: "Start Disabled" : 0
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
	counttarget(string) : "misc_targetnumber updated with current counter number"
	lip(choices) : "1=display counter goes up from zero, -1=counts down to zero" = [
		1 : "Count up from zero"
		-1 : "Count down to zero"
	]
]
//_____TRIGGER TIMER_____
@PointClass base(AppearFlags, targetname, target) color(128 0 25) size(-8 -8 -8, 8 8 8) = trigger_timer : "A timer with three (gold/siver/bronze) event triggers" [
	spawnflags(flags) = [
		32 : "Start Disabled"
		61 : "Start Off"
	]
	delay(integer) : "time delay BEFORE firing final result (def=1s)"
	wait(integer) : "time delay PAUSE before starting timer (def=0s)"
	timertarget(string) : "misc_targetnumber updated between start/finish"
	startmsg(string) : "Start of timer centerprint message"
	message(string) : "Stop of timer centerprint message"
	target(string) : "timer value 1 - trigger target(s) (Must Exist)"
	waitmin(integer) : "timer value 1 - TIME to trigger event"
	noise(string) : "timer value 1 - misc_targetnumber targetname (optional)"
	target2(string) : "timer value 2 - trigger target(s)"
	waitmin2(integer) : "timer value 2 - must be greater TIME than waitmin"
	noise2(string) : "timer value 2 - misc_targetnumber targetname (optional)"
	target3(string) : "timer value 3 - trigger target(s)"
	waitmin3(integer) : "timer value 3 - must be greater TIME that waitmin2"
	noise3(string) : "timer value 3 - misc_targetnumber targetname (optional)"
	spawndelay(integer) : "Setup time before entity can be used, useful if you want to start the timer at map-load (def=0.5, min=0.1)"
	
]
//_____TRIGGER ENGINE_____
//NOTE - NEEDS better descriptive text for comments and functionality
@PointClass base(targetname, target)size(-8 -8 -16, 8 8 16) color(0 0 255) = trigger_engine : "When targetted(triggered), it triggers target(s) when certain engines are active." [
    spawnflags(flags) = [ 
	    1 : "FITZ" : 0
	    2 : "DP" : 0
	    4 : "FTE" : 0
	   16 : "RAIN" : 0
	   32 : "SNOW" : 0  
	]
    wait(integer)  : "Wait" :  :  "-1 = will only fire targets once."
    delay(integer) : "Delay" :  : "Delay before firing (after being triggered)."
    cnt(integer)   : "Randomize" :  : "Random amount of time to add to delay."
]
//_____TRIGGER GIVEITEMS_____
@SolidClass base(AppearFlags, targetname, target) = trigger_giveitems : "A 'trigger brush' used to give items to the player. The target items only work when the 'delay spawned' or 'Start OFF' spawnflag is set. The item pickup sound can be turned off by adding a key/value pair of 'sounds' '4', to the item. The target items will not respawn or work more than once. NOTE - This entity is designed for itself to be triggered, for special use situations that are more 'event' based than location. NOTE: works with entity state system." [
    spawnflags(flags) = [ 
	    1 : "No Touch" : 0  : "Triggered via other entities"  
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
	//Patch2 addition
	target(target_destination) : "Target (Items ONLY)"
	target2(target_destination) : "Target2 (relays, entity states etc)"
	message(string)  : "Message" : : "Message to display when triggered"
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		0 : "Always reset"
	]
    angle(integer)   : "Direction(facing) to Activate" :  : "Facing Direction for the trigger to work, use '360' for angle 0. If not set activates from all directions."
    sounds(choices) : "Sound style" : 0 = [
		0 : "Default"
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"
	]
	noise(sound) : "Custom Sound"
]
//_____TRIGGER TAKEARTIFACT_____
@SolidClass base(AppearFlags, targetname, target, TrigSound) = trigger_takeartifact : "Trigger volume used to remove powerups from the player" [
    spawnflags(flags) = [ 
	    1 : "No Touch" : 0  : "Triggered via other entities"  
		2 : "id" : 0 : "Remove id artifacts (Quad, Pentgram, Ring, Envsuit)" 
		4 : "Arcane Dimensions" : 0 : "Remove AD artifacts (Nail Piercer, Sharp Shooter)"
		8 : "Vania" : 0 : "Remove Vania artifacts (Jump Boots, Blast Belt, Lavashield, Wetsuit)"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
	message(string) : "Message to display when triggered"
	waitmin(integer) : "Override timer for powerup, anything below value is ignored (def=0)"
	waitmin2(integer) : "Slow down timer for trigger working again (def=0.1s)"
	waitmin3(integer) : "Slow down timer for sound playing (def=1s)"
	wait(integer) : "-1 = trigger once functionality (def=0)"
]
	
//_____TRIGGER TELEPORT_____
//Teleport player/monsters to target location
//if targetname is setup, the teleporter requires a trigger to activate
//This entity cannot be damaged and is always touchable once activated
@SolidClass base(AppearFlags, targetname) 
	= trigger_teleport : "Trigger Teleport - Teleporters consist typically of three parts. Two brushes(a world brush with a special '*teleporter' texture and a 'trigger_teleport' brush) and an 'info_teleport_destination' point entity. Example, 1)Place an 'info_teleport_destination' somewhere in your map and give it a name of 'dest1'. 2)Now, in another part of your map draw out a 64X64X64 brush near floor level, give it a 'trigger' texture and then: r.click >'tie to entity/create brush entity > trigger> trigger_teleport', and give it a target of 'dest1'. 3)Lastly duplicate that brush, in place, and 'move to world/make structural' (r.click) and give it a teleporter texture. That's the basics, decorate/customize as needed." [
	target(target_destination) : "Target" : "Points to info_teleport_destination/info_teleportinstant_dest entity"
	spawnflags(Flags) = [
		1 : "Player Only" : 0 : "Can only be used by players (nothing else)"
		2 : "No Ambient" : 0 : "No teleporter ambient sound regardless of state"
		4 : "Start ON" : 0 : "Will start active regardless of targetname setting"
		8 : "Instant" : 0 : "Instant teleporter, no change to velocity, use with info_teleportinstant_dest"
		16 : "Projectiles" : 0 : "Allow projectiles to use regular/instant teleporters"
		32 : "No Tele FX" : 0 : "No player sound + FX when teleporting entities"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	wait2(choices) : "target2 only fires once" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	speed(integer) : "Speed after teleport (def=300)"
	target(string) : "Points to info_teleport_destination entity"
	target2(string) : "Can be used to fire additional targets"
	volume(integer) : "Teleport hum sound (def=0.5)"
	noise(sound) : "Custom sound to play when active (must be looped, def=hum1.wav)"
	waitmin(integer) : "Custom Sound Length(def=3.622)"
	waitmin2(integer) : "Time between teleport sound/fx (def=0.2s) being played"
	waitmin3(integer) : "Alpha value for debug lvl showing triggers ingame (def=0.75)"
	dmg(integer) : "damage from using the teleport trigger (def=0)"
	dmgskill(string) : "damage based on skill level X=Easy, Y=Normal, Z=Hard/NM (def=0,0,0)"
	debuglvl(choices) : "shows extra info" = [
		1 : "Impact markers"
		2 : "Impact arrows"
		3 : "Console text"
	]
	telefixangle(choices) : "Fixed or preserve angle direction for instant teleporters" = [
		0 : "Preserve angle (default)"
		1 : "Fixed angle"
	]
	no_trackondeath(choices) : "" = [
		0 : ""
		1 : "Homing projectiles don't stop tracking"
	]
]

//_____INFO_TELEPORTINSTANT_DEST_____
@SolidClass = info_teleportinstant_dest : "Destination for an instant teleporter" [
    targetname(target_source) : "link to trigger_teleport" 
	target(target_destination) : "fires when used as a destination (works only once)"
	angletarget(target_destination) : "targeting entity used for custom direction"
	angles(string) : "Pitch Yaw Roll (destination angle after teleporting)"
	teledest(integer) : "Unique number for multiple teleporter destinations"
]
//_____TRIGGER MAXHP_____
@SolidClass base(AppearFlags) = trigger_maxhp : "Change the player maximum hp and maximum mega values" [
	targetname(target_source) : "trigger entity (works with entity state system)"
	target(target_destination) : "trigger all these targets when activated"
	max_health(integer) : "Maximum Health for ALL the player / client"
	mega_health(integer) : "Maximum Health for picking up the mega health item"
	count(integer) : "Skill level (0=ALL, 1=EASY, 2=NORMAL, 4=HARD, 8=NM, 15=ALL)"
	wait(integer) : "-1=will only fire targets once (switches off)"
	sounds(integer) : "1=Secret,2=talk,3=switch,4=silent,6=secret2"
	noise(integer) : "custom sound to play when triggered"
	message(string) : "message to display when triggered"
]
//_____TRIGGER GRAVITY_____
@SolidClass base(AppearFlags) = trigger_gravity : "Trigger Gravity - change entity/entities/player or server (world) gravity" [
	spawnflags(Flags) = [
		1 : "NO Touch" : 0 : "Only triggered via other entities"
		2 : "Server" : 0 : "Change server gravity vs entity gravity"
		4 : "Player" : 0 : "Player(s) only can touch this trigger"
		8 : "Monsters" : 0 : "Monster(s) only can touch this trigger"
	   16 : "Reset" : 0 : "Reset any entity to default gravity (does not affect server)"
	   64 : "Start OFF" : 0 : "Requires trigger to activate"
	]
	targetname(target_source) : "Name" : : "Name to trigger this entity (works with entity state system)"
	target(target_destination) : "Target" : : "Entities to affect with gravity update"
	target2(target_destination)  : "Target2" : : "Fire event(s) everytime gravity is changed"
	count(integer) : "Gravity (server=0-1000 (def=800) entity=0-1, can be negative)"
	wait(integer) : "Wait (def -1)": : "-1, only fire targets once"
	waitmin2(integer) : "Minimum time between re-triggering fire events"
	noise2(sound) : "Custom Sound" : : "Sound to play everytime gravity is changed"
	waitmin(integer)  : "Minimum time between re-triggering sound"	
]
//Patch2 addition
//_____TRIGGER VELOCITY_____
@SolidClass base(AppearFlags) = trigger_velocity : "Trigger Velocity - Check for projectile / player velocity! This entity cannot be damaged and is always touchable." [
	spawnflags(Flags) = [
		1 : "Player" : 0 : "Player only trigger"
		2 : "Monster" : 0 : "Monster only trigger"
		4 : "Grenade" : 0 : "Grenade projectile only trigger"
		8 : "Rocket" : 0 : "Rocket projectile only trigger"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	targetname(target_source) : "Name" : : "Name used as a target by other entities (works with entity state system)"
	target(target_destination) : "Target" : : "Fire event(s) everytime trigger conditions successful"
	message (string)  :  "Message (conditions met)" : : "Display a message everytime trigger conditions successful"
	waitmin(integer) : "Target retrigger delay (def=1s)" : : "Time between target/message working again"
	target2(target_destination)  : "Target2" : : "Fire event(s) everytime trigger exceptions fail"
	message2(string)  : "Message2 (exceptions fail)" : : "Display a message everytime trigger exceptions fail"
	waitmin2(integer) : "Target2 retrigger delay (def=1s)" : : "Time between target2/message2 working again"
	wait(integer) : "Wait (def -1)" : : " -1, only fire the triggers functionality once"
	speed(integer) : "Minimum velocity speed to trigger (def=500)"
	angle(integer) : "Direction(facing) to Activate" : : "Facing Direction for trigger to work, use '360' for angle 0."
	ideal_yaw (integer) : "Facing angle sensitivity (def=0.3, range = 0 - 1)"
	delay (integer) : "Delay spawn(def 1 sec / -1 none)" : :  "-1 = No spawn delay, 0 (def=1s), +0 = spawn delay"
	dmg_take(integer) : "Grenades will explode on impact of this trigger"	
]
//_____TRIGGER PUSH_____
@SolidClass base(AppearFlags,targetname,target) = trigger_push : "Trigger Push" [
	spawnflags(flags) = [ 
		1 : "Once Only" : 0
		2 : "Silent" : 0
		4 : "No Monsters" : 0
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
	angle(integer)  : "Direction (-2=down, -1=up)"
	angles(integer) : "Direction2(X Y Z)"
	speed(integer)  : "Speed of push (def=1000)"
]
//_____TRIGGER FOG_____
@SolidClass base(AppearFlags,targetname,target) flags(Angle) = trigger_fog : "Trigger Fog" [
	spawnflags(flags) = [ 
		1 : "No Touch" : 0 : "can only be triggered via other entities"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	speed(integer) : "Time to fade (-1=Instant)"
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
		 2 : "Default"
	]
	angle(integer) : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."
	fog_density(integer) : "Fog Density (def=0.5)"
	fog_colour(color1) : "Fog Colour (0.1 0.1 0.1)"
]
//_____TRIGGER SKY FOG_____
@SolidClass base(AppearFlags,targetname,target)	= trigger_skyfog : "Trigger Skyfog - change global sky fog to new value over time" [
	spawnflags(flags) = [ 
		1 : "No Touch" : 0 : "can only be triggered via other entities"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	speed(integer) : "Time to fade (-1=Instant)"
	wait(integer) : "time between re-triggering (def=2s, -1=once)"
	angle(integer) : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."
	skyfog_density(integer) : "Skyfog density(def=0.5, -1=debug mode)"	
]
//_____TRIGGER LADDER_____
@SolidClass base(AppearFlags, targetname) = trigger_ladder : "Trigger Ladder" [
//Patch2 addition
	spawnflags(flags) = [ 
		4 : "Velocity" : 0 : "Will use the VELOCITY ladder system instead"
		8 : "FTE Ladder" : 0 : "FTE ladders do not require the spacebar to ascend/descend" 
		64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
		]
	angle(integer)   : "Direction(facing) to Climb" :  : "Direction(facing) required for the player to climb the ladder. Use '360' for angle 0."
	waitmin(integer) : "Time between climbing sound"
	speed(integer) : "Velocity to climb (def=160)"
	sounds(choices) : "Sounds" = [
		1 : "Metal"
		2 : "Wood (def)"
		3 : "Rope"
		4 : "Silent"
		5 : "Custom"
	]
	noise1(sound) : "Custom Sound - Climb 1"
	noise2(sound) : "Custom Sound - Climb 2"
	noise3(sound) : "Custom Sound - Climb 3"
	noise4(sound) : "Custom Sound - Climb 4"
	yaw_speed(integer) : "VELOCITY spawnflag only - Movement distance for sound trigger"
	distance(integer) : "VELOCITY spawnflag only - Amount of velocity to push towards ladder (stickyness)"
	lip(integer) : "VELOCITY spawnflag only - Change the step amount at the top of the ladder"
	height(integer) : "VELOCITY spawnflag only - Default velocity upward if not doing anything on ladder"
	pos1(vector) : "VELOCITY spawnflag only - Speed adjustment for X=strafe, Y=up and Z=down movement"
	pos2(vector) : "VELOCITY spawnflag only - X=Strafe velocity, Y=Up/Down angle, Z=MIN velocity for up/down"

]
//_____BUBBLE SETUP for HURT and HEAL_____
@baseclass base(AppearFlags) = TrigBubbles [
	spawnflags(flags) = [ 
		2 : "Bubbles" : 0 : "Spawn bubbles within trigger volume when active" 
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
		]
	count(integer) : "Bubble active total"
	height(integer) : "Bubble Max Travel distance"
	style(choices) : "Bubble Type" = [
		1 : "Grey"
		2 : "Brown 1"
		3 : "Blue 1"
		4 : "Green 1"
		5 : "Red 1"
		6 : "Brown 2"
		7 : "Pink / Yellow"
		8 : "Brown 3"
		9 : "Purple 1"
		10: "Purple 2"
		11: "Brown 4"
		12: "Green 2"
		13: "Yellow"
		14: "Blue 2"
		15: "Red 2"
	]
	yaw_speed(integer) : "Spawn Rate" :  : "Spawning rate (def=0.5) for bubbles (speed + random() x speed)."
]
//_____Trigger Hurt Settings_____
@baseclass = TriggerHurtSettings  [
    dmg(integer) : "Damage (def=5)"
	wait(integer) : "Time between pain touch (def=1s)"
	speed(integer) : "Falling Velocity (def=300)"
]
//_____TRIGGER HURT_____
@SolidClass base(targetname, TriggerHurtSettings, TrigBubbles) = trigger_hurt : "Trigger Hurt" [
    	//ERROR? - target has been removed(DEF file), correct?
        spawnflags(flags) = [ 
		4 : "Monster ONLY" : 0 : "Will only affect monsters"	
		16: "MOD Check" : 0 : "Will remove this entity if THIS mod is active"
		32: "Falling" : 0 : "Only hurts if the player is falling (speed=velocity)"
	]
	dmgskill(string) : "damage based on skill level X=Easy, Y=Normal, Z=Hard/NM (def=0,0,0)"
]
//_____Trigger Heal Settings_____
@baseclass = TriggerHealSettings  [
    target(target_destination) : "target - first heal"
	target2(target_destination) : "target - healing expired"
	wait(integer) : "Time between heals (def=1s)"
	healamount(integer) : "Heal Amount (def=10)"
	max_health(integer) : "Max Amount to Heal (def=50, -1=no limit)"
	sounds(choices) : "Sounds" = [
		//ERROR? - REMOVED in DEF, correct? (0 : "Silent")
		1 : "Heal 15(def)"
		2 : "Heal 25"
		3 : "Heal 100"
		4 : "Respawn"
		5 : "Custom"
	]
	noise(sound) : "Custom Sound"
	lip(choices) : "Block Message" = [
		0 : "Do Nothing"
		1 : "Block Healing"
		2 : "Block All"
	]
	message(string) : "Healing Message"
	message2(string) : "Healing Expired"
]
//_____TRIGGER HEAL_____
@SolidClass base(AppearFlags, targetname, TriggerHealSettings, TrigBubbles) = trigger_heal : "Trigger Heal" []

//_____TRIGGER TOUCH SOUND_____
@SolidClass base(AppearFlags, targetname) = trigger_touchsound : "Trigger Touch Sounds" [
	spawnflags(flags) = [
		4 : "World Geo" : 0 : "Drawn bmodel (not just a trigger)"
		8 : "Drain" : 0 : "Drain effect when trigger_disabled"
	  64 : "Start OFF" : 0 : "Starts OFF, waits for trigger" 
	]
	message(choices) : "Sounds" = [ 
        1 : "Water (DEF)"
        2 : "Slime"
        3 : "Lava"
		4 : "Silent"
		5 : "Custom"
	]
	noise(sound) : "Custom Touch Sound"
	noise1(sound) : "Custom Exit Sound"
	noise2(sound) : "Custom Drain Sound"
	speed(integer) : "Drain Time"
	yaw_speed(integer) : "Drain Movement"
	super_time(integer) : "Time delay playing drain sound"
	water_alpha(integer) : "Liquid Alpha"
]
//_____TRIGGER CHANGE LEVEL_____
@SolidClass base(AppearFlags, targetname, target) = trigger_changelevel : "Trigger Change Level" [
	spawnflags(flags) = [ 
		1 : "No Intermission"   : 0 : "No Intermission screen"
		2 : "Reset Inventory"   : 0 : "Reset player inventory to default (Shotgun+Shells)"
		4 : "USE Player Start2" : 0 : "Start at second info_player spawn" 
	  64 : "Start OFF" : 0 : "Starts OFF, waits for trigger" 
	]
	map(string) : "Map Name" : : "Leave blank to reload same map"
	startspawn2(integer) : "Spawn number(1->7) in next map" :  : "Special unique number (1-7) which must match info_player_start2"
	mapvar_update(string) : "Map Variable Update (Range X->Y=Z)" :  : "Essentially (X->Y=Z) simply states that, X thru Y is a range of variables(0-132 available) and that Z is a value of either 0 or 1. Thus, setting 'mapvar_update' to '0 3 1' would set variables 0 thru 3 to equal 1."
]
//_____TRIGGER SET SKILL_____
@SolidClass base(AppearFlags, targetname) = trigger_setskill : "Trigger Set Skill" [
	spawnflags(flags) = [ 
		1 : "No Touch" : 0 : "Can only be triggered via other entities"
	  64 : "Start OFF" : 0 : "Starts OFF, waits for trigger"
	]
	//ERROR? - target removed in DEF file, correct?
	message(choices) : "Skill to change to" = [
        0 : "Easy"
        1 : "Medium"
        2 : "Hard"
        3 : "Nightmare!"
	]
	health(integer) : "Health (Damage to activate)"
	wait(integer) : "Time between re-trigger (def=0.2, -1=once)"
	angle(integer) : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."	
]
//_____TRIGGER RUNE_____
@SolidClass base(AppearFlags, targetname) = trigger_rune : "There are two ways this trigger can be used. As a single check for multiple runes using the 'target' key OR individual triggers for runes using the 'noise' 1-4 keys. This trigger is designed to work once when the rune conditions are met" [
	spawnflags(flags) = [
		1 : "Rune 1"
		2 : "Rune 2"
		4 : "Rune 3"
		8 : "Rune 4"
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger" 
	]
    target(target_destination) : "RUNE 'MIXTURE' - targets to fire"
	noise1(target_destination) : "RUNE 1 - targets to fire"
	noise2(target_destination) : "RUNE 2 - targets to fire"
	noise3(target_destination) : "RUNE 3 - targets to fire"
	noise4(target_destination) : "RUNE 4 - targets to fire"
	health(integer) : "Health"	
    angle(integer) : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
]
//_____TRIGGER MONSTER JUMP_____
@SolidClass base(AppearFlags, targetname, target) = trigger_monsterjump : "Push monsters in a certain direction. This entity cannot be damaged and is always touchable once activated." [
	spawnflags(flags) = [
		2 : "Flying Monsters"
		4 : "Swimming Monsters"
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	angle(integer)  : "Direction (-2=down, -1=up)"
	speed(integer) : "Jump Speed (def=200)"
	height(integer) : "Jump Height (def=200)"
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	noise1(string) : "Monster classname ONLY can use trigger"
	mangle(integer) : "Facing direction for activating the trigger"
	target2(string) : "Targets to fire when the trigger is used"
	angletarget(target_destination) : "Targeting entity used for custom direction"
]
//_____TRIGGER DROLE JUMP_____
@SolidClass base(AppearFlags, targetname, target) = trigger_drolejump : "Trigger Drole Jump NOTE: Will only work for ENRAGED Droles" [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	angle(integer)  : "Direction (-2=down, -1=up)"
	speed(integer) : "Jump Speed (def=200)"
	height(integer) : "Jump Height (def=200)"
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]	
]
//_____TRIGGER MONSTER NO JUMP_____
@SolidClass base(AppearFlags, targetname) = trigger_monsternojump : "Stop monsters from using jump attacks." [
    spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
    wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	delay(integer)   : "Delay - jump attack by (def=0.5s)"
	waitmin(integer) : "Re-trigger timer (def=0.1s)"
	noise1(string) : "Monster classname ONLY can use trigger"
] 
//_____TRIGGER MONSTER DROP_____
@PointClass base(AppearFlags, targetname) size (-8 -8 -8, 8 8 8) color(0 128 128) = trigger_monsterdrop : "Drop monster(s) to the floor" [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	height(integer) : "Speed - thrown upwards (def 50)"	
]
//_____TRIGGER MONSTER TURRET_____
@SolidClass base(AppearFlags,targetname) = trigger_monsterturret : "Trigger Monster Turret - Temporarily turn a monster into a turret" [
	//ERROR - target was removed in DEF, correct?
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	wait(choices) : "Wait before reset" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
	count(choices) : "Random chance to pause(range 0->1)" = [
		-1   : "Constant"
		0.25 : "Default"
	]
	noise1(string) : "Monster Classname(monster_ogre) ONLY Use"
]
//_____TRIGGER MONSTER MOVESPEED_____
@PointClass base(targetname, target) size(-8 -8 -16, 8 8 16)  color(128 0 128) = trigger_monstermovespeed : "Change movement speed" [
	state(choices) : "Monster Movement" = [
		-1 : "No Movement"
		 0 : "Toggle (Default)"
		 1 : "Free Movement"
	]
	wait(choices) : "Once Only" = [
		-1 : "Trigger Once"
		 0 : "Always reset"
	]
]
//Patch2 addition
//_____TRIGGER MONSTER PASSIVE STATE_____
// NO spawnflags indicated???
@PointClass base(AppearFlags,targetname,target) size(-8 -8 -16, 8 8 16) color(128 0 128) = trigger_monsterpassivestate : "Change the monster(s) passive state" [
	state(choices) : "State to change to" = [
	   -1 : "Toggle"
		0 : "Off"
		1 : "On"
	]
	wait(choices) : "Trigger Once" = [
	   -1 : "Yes"
		0 : "No (multiple)"
	]
]
//_____TRIGGER ITEM RESPAWN_____
@PointClass base(targetname, target) size(-8 -8 -16, 8 8 16) color(128 0 128) = trigger_itemrespawnupd : "Change the state of respawn flag on items. Useful for switching off respawning items after arena fight is over" [
	spawnflags(flags) = [ 16 : "Respawn" : 0 : "Value of respawn flag to copy to item" ]
]
//_____TRIGGER CLIENT MESSAGE_____
@PointClass base(targetname) size(-8 -8 -16, 8 8 16) color(128 128 0) = trigger_clientmsg : "Client message" [
	//ERROR - target was removed in DEF, correct?
	message(string) : "Message"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"
	]
	noise(sound) : "Custom Sound - Triggered"
]
//_____TRIGGER CD TRACK_____
@PointClass base(targetname) size(-8 -8 -8, 8 8 8) color(200 128 0) iconsprite("sprites/cd_track.spr") = trigger_cdtrack : "Allows for CD/Music Track change to occur mid map. Suitable for ALL clients. Non CD external music tracks(.ogg/.mp3) are typically named with the format of: track01,  track02... track99 etc. Only the trailing numbers are required for 'Track Number'. NOTE - Quakespasm looks for music files in '... id1/music' while Darkplaces looks in '... id1/sound/cdtracks'. Using a Mod directory is also acceptable(ex '... ad/music' or '... ad/sound/cdtracks'." [
    count(integer) : "Track Number (ex 02->xx)" :  : "Number of the CD/Music Track to Play/Change to."
]
//_____TRIGGER SKY BOX_____
@PointClass base(targetname) size(-16 -16 -8, 16 16 8) color(230 230 230) = trigger_skybox : "Allows for a custom Skybox change to occur mid map. Suitable for ALL clients. Skyboxes(.tga) are typically referenced as: interstellar_, moonrise_, voidsmoke_ etc with these letters(bk, dn, ft, lf, rt, and up) appended at the end. The underscore is not neccesary but used for clarity. The important part is to just leave off the last 'two' trailing letters from the name of your skybox for 'Skybox Name'. NOTE: Directory paths are allowed so, '...env/mycustomfolder/mycustomsky_' is perfectly valid. NOTE - Quakespasm/Darkplaces both look for skybox files in '...id1/gfx/env/'. Using a Mod directory is also acceptable(ex '... ad/gfx/env'." [
    message(string) : "Skybox Name (EX: interstellar_)" :  : "Name of the Skybox to Load/Change to."
]
//_____TRIGGER MONSTER KILL_____
@PointClass base(targetname,target) size(-8 -8 -16, 8 8 16) color(128 0 128) = trigger_monsterkill : "Remove monster(s) from the map" [
	spawnflags(flags) = [
		16 : "Death" : 0 : "kill monsters via death function"
		//Patch2 addition
		32 : "GIB" : 0 : "Gib monsters via death function"
	]
]
//_____TRIGGER MONSTER ATTACK_____
@PointClass base(targetname, target, target2) size(-8 -8 -16, 8 8 16) color(128 0 128) = trigger_monsterattack : "Force Monster Attack" [
]
//_____TRIGGER VOID_____
@SolidClass base(AppearFlags, targetname) = trigger_void : "Trigger Void - 'Garbage collector for bottom of skyboxes'." [
    //ERROR? - target removed in DEF file, correct?
	spawnflags(flags) = [
		1 : "Ignore Clients" : 0 : "Ignore clients (anything flagged as a client)"
		2 : "Ignore Monsters" : 0 : "Ignore monsters (anything flagged as a monster)"
		4 : "Ignore Ammo" : 0 : "Ignore ammo types (all ammo projectile types)"
		8 : "Ignore Minion eggs" : 0 : "Ignore minion eggs (affects shalrath, wraiths)"
		16: "Ignore Temporary ents" : 0 : "Ignore temporary ents (gibs, sparks, smoke)"
		32: "Ignore Items" : 0 : "Ignore items (weapons,armor,keys,runes,powerups)"
	   64 : "Start OFF" : 0 : "Starts OFF, waits for trigger"
	]
]
//_____DOOR STATE_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -16,8 8 16) color(0 200 128) = trigger_doorstate : "Trigger func_door(s) to exact state (open/close)" [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]	
	target(target_destination) : "Target (func_door's ONLY)"
	state(choices) : "Door State" = [	
		1 : "Open"
		0 : "Closed"		
	]
	wait(choices) : "Trigger" = [
		0 : "Default"
	   -1 : "Only Once"
	]
]

//------------------------- Entity State OPTIONS ------------------------
 
//_____ENTITY STATE ON_____
@PointClass base(AppearFlags, targetname, TriggerRelaySettings) size(-8 -8 -8, 8 8 8) color(0 255 0)
	= trigger_entitystate_on : "Entity state ON - Switch the target(s) entity state ON." [
	target(target_destination) : "targets to affect"
	target2(target_destination) : "More targets to affect"
	wait(integer) : "-1 = will only fire targets once"
	delay(integer) : "Delay before firing (after being triggered)"
	cnt(integer) : "Random amount of time to add to delay"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"]
	noise(string) : "Custom sound to play when triggered"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____ENTITY STATE OFF_____
@PointClass base(AppearFlags, targetname, TriggerRelaySettings) size(-8 -8 -8, 8 8 8) color(255 0 0)
	= trigger_entitystate_off : "Entity state OFF - Switch the target(s) entity state OFF." [
	target(target_destination) : "targets to affect"
	target2(target_destination) : "More targets to affect"
	wait(integer) : "-1 = will only fire targets once"
	delay(integer) : "Delay before firing (after being triggered)"
	cnt(integer) : "Random amount of time to add to delay"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"]
	noise(string) : "Custom sound to play when triggered"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____ENTITY STATE DISABLE_____
@PointClass base(AppearFlags, targetname, TriggerRelaySettings) size(-8 -8 -8, 8 8 8) color(128 128 128)
	= trigger_entitystate_disable : "Entity state DISABLE - Switch the target(s) entity state DISABLE." [
	target(target_destination) : "targets to affect"
	target2(target_destination) : "More targets to affect"
	wait(integer) : "-1 = will only fire targets once"
	delay(integer) : "Delay before firing (after being triggered)"
	cnt(integer) : "Random amount of time to add to delay"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"]
	noise(string) : "Custom sound to play when triggered"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____ENTITY STATE RESET_____
@PointClass base(AppearFlags, targetname, TriggerRelaySettings) size(-8 -8 -8, 8 8 8) color(0 0 255)
	= trigger_entitystate_reset : "Entity state RESET - Switch the target(s) entity state RESET." [
	target(target_destination) : "targets to affect"
	target2(target_destination) : "More targets to affect"
	wait(integer) : "-1 = will only fire targets once"
	delay(integer) : "Delay before firing (after being triggered)"
	cnt(integer) : "Random amount of time to add to delay"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"]
	noise(string) : "Custom sound to play when triggered"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]
//_____ENTITY STATE AFRAME_____
@PointClass base(AppearFlags, targetname, TriggerRelaySettings) size(-8 -8 -8, 8 8 8) color(120 210 255)
	= trigger_entitystate_aframe : "Entity state AFRAME - Switch the target(s) AFRAME(animation frame) state. Targets are currently limited to 'func_wall/illusionary' entities, which have special textures applied. Think of it like this - textures with a common name but prefixed in a sequentially 'numbered' fashion, such as this typical ID base button('+0basebtn','+1basebtn'(blinking red), will be animated. THIS is the 'primary' frame(s) state. When the 'button' is used, it switches to the sequential 'alphabetically' prefixed texture(s), if available. The 'alternate' frame(s) state('+abasebtn'(yellow image). Either 'state' can be a single image, but there MUST BE one of each for a switch to occur. NOTE - The targetted entities also have an 'AFrame' spawnflag that can be set, which starts them in the map WITH the 'alternate' frame(s) displayed. Something to keep in mind." [
	target(target_destination) : "Target (a func_wall/illusionary)"
	target2(target_destination) : "Taget2 (more targets)"
	state(choices) : "Aframe state" :  : "0=Primary frame(s)(+0,+1,+2 etc) and 1=Alternate frame(s)(+a,+b,+c etc)" = [
		0 : "Primary Frame(s)"
		1 : "Alternate Frame(s)"
	]
	wait(integer) : "-1 = will only fire targets once"
	delay(integer) : "Delay before firing (after being triggered)"
	cnt(integer) : "Random amount of time to add to delay"
	sounds(choices) : "Sound style" : 0 = [
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"]
	noise(string) : "Custom sound to play when triggered"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
]

//----------------------- Map VARIABLE OPTIONS ------------------------

//NOTE - MapVar is Fully functional, just needs better descriptive text for keys and information.

@baseclass = MapVarCommon [
    count(integer)   : "Variable Name (Numeric (0->132)" :  : "Define a map Variable to check (range checks)"
    target(target_destination) : "Target (for val==0)"   :  : "if map Variable is equal to 1, then fire these target(s)"
    target2(target_destination) : "Target2 (for val==1)"  :  : "if map Variable is equal to 0, then fire these target(s)"
    noise(target_destination) : "Bmodel (AFrame) Object"  :  : "Target an Aframe object to change it's texture state. See 'trigger_entitystate_aframe' for more information."
    wait(integer) : "Wait (Time before re-triggering)" :  : "Wait before re-triggering, -1 = trigger once"
]
//_____MAP VARIABLE QUERY_____
@PointClass base(targetname , MapVarCommon) size(-8 -8 -16, 8 8 16) color(92 92 92) = trigger_mapvar_query : "Trigger target(s) based on a value returned by mapvar query." []

//_____MAP VARIABLE UPDATE_____
@PointClass base(targetname, MapVarCommon) size(-8 -8 -16, 8 8 16) color(172 172 172)  = trigger_mapvar_update : "Update the value of a Map Variable" [ 
    cnt(integer) : "Variable Value (0 or 1)" :  : "Assigns a Value(0/1), to the Variable defined in Variable Name('count') " 
]
//_____MAP VARIABLE TOGGLE_____
@PointClass base(targetname, MapVarCommon) size(-8 -8 -16, 8 8 16) color(252 252 252) = trigger_mapvar_toggle : "Toggle the value of a Map Variable." []

//_____MAP VARIABLE MULTIPLE_____
@SolidClass base(AppearFlags, targetname) = trigger_mapvar_multiple : "Touch trigger target(s) based on mapvar" [
    spawnflags(flags) = [ 
		32 : "Monsters" : 0  : "Can be touched/triggered by monsters"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	//MapVarCommon was not used here to keep the formatting visually logical in editor
    count(integer)   : "Variable Name (Numeric (0->132)" :   : "Define a map Variable to check (range checks)"
    target(integer)  : "Target (for val==0)"   :  : "if map Variable == 0, then fire these target(s)"
    message(string)  : "Message"  :   : "if map Variable is equal to 0, then display this message"
    target2(integer) : "Target2 (for val==1)"  :  : "if map Variable == 1, then fire these target(s)"
    message2(string) : "Message2" :   : "if map Variable is equal to 1, display this message"
    health(integer)  : "Health (Takes Damage)"
    wait(integer)    : "Wait (Time before re-triggering)" :  : "Wait before re-triggering, -1 = trigger once"
    delay(integer)   : "Delay (before firing)"
    angle(integer)   : "Direction(facing) to Activate" :  : "Facing Direction for trigger to work, use '360' for angle 0."
    sounds(choices) : "Sound style" : 0 = [
		0 : "Default"
		1 : "Secret"
		2 : "Beep beep"
		3 : "Large switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret 2"
	]
	noise(sound) : "Custom Sound (triggered)"
]

//======================================================================
//
// MISC entities
//
//======================================================================

//_____PARTICLE_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -8, 8 8 8) color(0 128 192) = misc_particle : "Particle Emitter" [
	spawnflags(Flags) = [ 64 : "Start off" : 0 : "Starts off, waits for trigger" ]
	target(string) : "target destination of effect"
	target2(string) : "Name of particle template"
	message(choices) : "Particle Style" = [
		"ALTAR" : "ALTAR - Blood red"
		"ARMOR1" : "ARMOR1 - Green"
		"ARMOR2" : "ARMOR2 - Yellow"
		"ARMOR3" : "ARMOR3 - Red"
		"BOOK" : "BOOK Runes"
		"ELECTRIC" : "ELECTRIC stream"
		"FCIRCLE" : "FCIRCLE - Floor circle"
		"FLAMES" : "FLAMES - Small"
		"FLAMEL" : "FLAMEL - Large"
		"JUMPAD" : "JUMPPAD - Upward"
		"KEYGOLD" : "KEYGOLD - Yellow"
		"KEYSILVER" : "KEYSILVER - Blue"
		"KEYRED" : "KEYRED - Red"
		"KEYGREEN" : "KEYGREEN - Green"
		"KEYPURPLE" : "KEYPURPLE - Purple"
		"KEYWHITE" : "KEYWHITE - White"
		"MEGAH" : "MEGAH - MegaHealth"
		"PENT" : "PENT - of protection"
		"PORTAL" : "PORTAL - White"
		"QUAD" : "QUAD - Damage"
		"SIGIL" : "SIGIL - Purple"
		"SRING" : "SRING - Ring of Shadows"
		"SUIT" : "SUIT - Env suit"
		"SKILL" : "SKILL - Pillar"
		//NEW additions
		"BSKILL" : "SKILL - Pillar(Blue)"
		"GSKILL" : "SKILL - Pillar(Green)"
		"PSKILL" : "SKILL - Pillar(Purple)"		
	]
]
//_____PARTICLE BURST_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -8, 8 8 8) color(0 128 192) = misc_particle_burst : "Particle Burst Emitter" [
	part_ofs(string) : "Particle Origin Offset(def=0 0 0)"
	part_tcount(integer) : "Particle Quantity (def=20)"
	part_life(integer) : "Particle Life time (def=2s)"
	part_style(choices) : "Particle Colour" = [
		0 : "White(def)"
		1 : "Yellow"
		2 : "Green"
		3 : "Red"
		4 : "Blue"
		5 : "Purple"
		6 : "Fire"
		7 : "White"
	]
	part_movetype(choices) : "Particle Movement" = [
		0 : "Default - Center"
		2 : "Center"
		3 : "Up"
		4 : "Shockwave"
		5 : "Skull"
		6 : "Lost"
		7 : "Minotaur"
	]	
]
//_____PARTICLE TEMPLATE_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -8, 8 8 8) color(0 128 192) flags(Angle) = misc_particletemplate : "Particle Template" [
	spr_name1(string) : "Sprite filename 1"
	spr_name2(string) : "Sprite filename 2"
	spr_name3(string) : "Sprite filename 3"
	part_movetype(integer) : "Movement (def=8)"
	part_limit(integer) : "Max active particles (def=25)"
	part_life(integer) : "Life time (def=1s)"
	part_ofs(string) : "Emitter offset (X Y Z)"
	part_veltype(choices) : "Velocity Type" = [
		0 : "Volume"
		1 : "Circumference"
		2 : "Random Circumference"
		3 : "Spiral"
		5 : "Explosion(def)"
	]
	part_velbase(string) : "Velocity Direction (Additive)"
	part_vel(string) : "Velocity Linear/random"
	part_velrand(string) : "Velocity random wobble"
	part_velrot(integer) : "Velocity rotation (Y Axis only)"
	part_vol(string) : "Volume to spawn within"
	wakeup_dist(integer) : "Wake up distance (def=1024)"
	wakeup_timer(integer) : "Wake up timer (def=1s)"
	spawn_base(integer) : "Spawn rate time (0.1s)"
	spawn_rand(integer) : "Spawn rate randomness"
	dpp_name(string) : "DP Particle effect name"
	dpp_wait(integer) : "DP spawn rate timer (def=0.1s)"
	dpp_rnd(integer) : "DP spawn rate randomness"
	dpp_vel(string) : "DP directional velocity"
]
//_____BUILTIN EFFECTS_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -8, 8 8 8) color(0 128 192) = misc_builtineffects : "Particle Builtin" [
	target(string) : "target destination of effect"
	wait(integer) : "Start Delay (def=0)"
	delay(integer) : "Start Delay (random)"
	count(choices) : "Type of effect" = [
		0 : "TE_SPIKE (def)"
		1 : "TE_SUPERSPIKE"
		2 : "TE_GUNSHOT"
		3 : "TE_EXPLOSION"
		4 : "TE_TAREXPLOSION"
		5 : "TE_LIGHTNING1"
		6 : "TE_LIGHTNING2"
		7 : "TE_WIZSPIKE"
		8 : "TE_KNIGHTSPIKE"
		9 : "TE_LIGHTNING3"
		10: "TE_LAVASPLASH"
		11: "TE_TELEPORT"
	]
]
//Patch2 addition
//_____MARSHLIGHT_____
@PointClass base(AppearFlags) size(-8 -8 -8, 8 8 8) color(128 128 192) = misc_marshlight : "Marsh lights" [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	targetname(target_source) : "Name" : : "Toggleable (use trigger ent for exact state)"
	color(choices) : "Color" = [
       0 : "White"
       1 : "Cyan"
       2 : "Blue"
       3 : "Green"
       4 : "Orange"
       5 : "Red"
       6 : "Purple"
	]	
	count(integer) : "Maximum active marsh lights (def=5)"
	mdl(string) : "Small sprite (def='progs/s_marsh_small.spr')"
	headmdl(string) : "Medium sprite (def='progs/s_marsh_med.spr')"
	waitmin(integer) : "Reset movement timer (def=6s)"
	waitmin2(integer) : "Reset Velocity movement (def=4.5s)"
	distance(integer) : "Starting distance from center (def=20)"
	pos1(integer) : "Pos1 (see help)" : : "used for selection of frame(s) has several setups, X=0, Y=0, Z=exact frame number X->Y, Z=0 Randomly pick a frame from the X,Y range, X->Y, Z=-1 Animate between the X,Y range"
	pos2(integer) : "Pos2 (see help)" : : "used for the selection of skin(s) has several setups, X=0, Y=0, Z=exact skin number X->Y, Z=0 Randomly pick a skin from the X,Y range"
	pos3(integer) : "Pos3 (see help)" : : "Base rotation avelocity (def=0 0 0)"
	finalangle(integer) : "Random rotation avelocity (def=0 0 0)"
	speed(integer) : "Override for frame animation speed (def=0.1s)"
	lip(choices) : "Frame animation direction" = [
		-2 : "Random"
		-1 : "Backwards"
		1 : "Forward (default)"
	]
]
//Patch2 addition
//_____GIB FOUNTAIN_____
@PointClass size(-8 -8 -8, 8 8 8) color(0 128 200) = misc_gibfountain : "A GIB fountain - spew Gibs in target direction (Originally from Zerstorer MOD)" [
	spawnflags(Flags) = [ 64 : "Start off" : 0 : "Starts off, waits for trigger" ]
	targetname(target_source) : "Name" : : "Toggleable (use trigger ent for exact state)"
	target(target_destination) : "Target (entity for direction)"
	gibtype(choices) : "Gib Type" = [
		0 : "Blood (def)"
		1 : "Stone"
       10 : "Poison"
    ]
	style(choices) : "Gib Style" = [
		0 : "Random (def)"
		1 : "Arm/Leg"
		2 : "Torso"
		3 : "Slice"
		4 : "Small"
		5 : "Large"
	]
	gibpartstyle(choices)  : "GIB Particle Colour" = [
		1 : "Yellow" 
		2 : "Green"
		4 : "Red" 
		8 : "Blue"
	   16 : "Purple" 
	   32 : "Fire" 
	   64 : "White"
	]
	gibpartbase(integer) : "Particle quantity(min)" : : "Base (minimum) value"
	gibpartrnd(integer) : "Particle quantity (random)" : : "Random amount to add"
	count(integer) : "GIB Quantity (def=1)" : : "Number to throw at once"
	cnt(integer) : "GIB random Quanity (def=0)" : : "Extra random quanity of gibs to throw"
	sounds(choices) : "Sounds" = [
		1 : "Zerstorer(def)"
		4 : "Silent"
		5 : "Custom"
	]
	noise(sound) : "Custom sound (launching)" : : "For launching gibs"
	noise1(sound) : "Custom sound (random)" : : "For launching gibs (random selection)"
	gib1exp(choices) : "Gib(sprite) Explosion (def=0, off)" : : "Sprite Explosion (1=small 2=medium 3=large 11-13=plasma 21-23=poison 31-33=electric 41-43=smoke)" = [
		0 : "Off (def)"
		1 : "Fire1 (small)"
		2 : "Fire2 (medium)"
		3 : "Fire3 (Large)"
		11 : "Plasma1 (small)"
		12 : "Plasma2 (medium)"
		13 : "Plasma3 (Large)"
		21 : "Poison1 (small)"
		22 : "Poison2 (medium)"
		23 : "Poison3 (Large)"
		31 : "Electric1 (small)"
		32 : "Electric2 (medium)"
		33 : "Electric3 (Large)"
		41 : "Smoke1 (small)"
		42 : "Smoke2 (medium)"
		43 : "Smoke3 (Large)"
	]
	
//----- Damage/Movement -----
	 
	gib1dmg(integer) : "Damage touching (def=0)" : :  ">1=damage inflicted on the player when touching gibs"
	angle(integer) : "Direction (def=-1 UP)" : : "Determines the firing direction (def=-1 UP)"
	speed(integer) : "Speed (forward (def=600)"
	gibvel(integer) : "Random Velocity (def=200 100 0)" : : "X=Forward, Y=L/R, Z=U/D (def=200 100 0)"
	delay(integer) : "Spawn Delay (def 3s) " : : "Base time between spawning gibs (default 3)"
	wait(integer) : "Random Time (def 5s)" : : "Random time between spawning, default 5 (= time + self.delay + (random() x self.wait) )"

//----- Custom Gib 1 Setup -----
	
//Gib 1
	gib1mdl(studio) : "Gib 1 model" : : "Define your own custom GIBS 1"
	gib1skin(integer) : "Gib 1 skin number (def=0)"
	gib1frame(integer) : "Gib 1 range to randomly pick from"
	gib1sound(choices) : "Gib 1 Impact sound" = [
		0 : "Light flesh"
		1 : "Heavy flesh"
		5 : "Acid"
		50 : "Custom"
	]
	gib1soundx(sound) : "Custom Gib 1 Impact sound" : : "WAV file (must set gib1sound=50)"

//----- Custom Gib 2 Setup -----
	
//Gib 2		
	gib2mdl(studio) : "Gib 2 model" : : "Define your own custom GIBS 2"
	gib2skin(integer) : "Gib 2 skin number (def=0)"	
	gib2frame(integer) : "Gib 2 range to randomly pick from"
	gib2sound(choices) : "Gib 2 Impact sound" = [
		10 : "Light Stones"
		11 : "Pebbles"
		12 : "Pebbles2" 
		20 : "Wood" 
		40 : "Metal1"
		50 : "Custom"
	] 
	gib2soundx(sound) : "Custom Gib 2 Impact sound" : : "WAV file (must set gib1sound=50)"

//----- Custom Gib 3 Setup -----

//Gib 3
	gib3mdl(studio) : "Gib 3 model" : : "Define your own custom GIBS 3"
	gib3skin(integer) : "Gib 3 skin number (def=0)"
	gib3frame(integer) : "Gib 3 range to randomly pick from"
	gib3sound(choices) : "Gib 3 Impact sound" = [
		41 : "Metal2" 
		42 : "Chain" 
		50 : "Custom"
	]
	gib3soundx(sound) : "Custom Gib 3 Impact sound" : : "WAV file (must set gib1sound=50)"
	
//----- Advanced Settings -----

	gibmins(integer) : "Bbox Model Override(mins)" : :  "Bounding box override for gib model (def='0 0 0')"
	gibmaxs(integer) : "Bbox Model Override(max)" : : "Bounding box override for gib model (def='0 0 0')"
	gibpartlife(integer) : "Particles Lifetime (secs)" : : "Lifetime (seconds) of particles from gibs"
	gibpartoffset(integer) : "Particles Offset" : : "Offset to particle origin (center of effect)"
	gibpartchance(integer) : "% chance of particle effect being active while on floor"
	gibAnimstart(integer) : "Starting animation frame for sequence"
	gibAnimfinal(integer) : "Final animation frame (>0) to enable sequence"
	gibAnimTimer(integer) : "Time (seconds) spent in final impact animation"
]
//Patch2 addition CURRENT
@PointClass base(AppearFlags,targetname) size(-16 -16 -16,16 16 16) color(255 128 128) flags(Angle) = misc_camera : "Ingame cinematic camera(No COOP/DM), will fade/move based on times in seconds. The first fade (out) is from  previous camera to background colour. The second fade (in) is to current camera view. The linear movementwill  start at the same time as the fade in process. Start -> Fade Out(waitmin1) -> Fade In(waitmin2)  / Movement (waitmin3) Once 'Fade in' has finshed then the pause timer (wait) starts.Waitmin3 = Waitmin2 + Wait (Sync everything to finish together) To sync the final camera to a player start, finish 22 map units above angles = up/down, angle, tilt left/right 'pitch roll yaw'up/left = negative value, down/right = positive valuedeathtarget, modeltarget & returntarget have to be defined on first cameraBe aware that coop is not supported, so be careful of trigger eventsand decide on a coop not working message2." [
	spawnflags(Flags) = [ 
		1 : "Player" : 0 : "Show the player model when starting cinematics"
		2 : "Skipable" : 0 : "Allow the cinematic to be skipped (exit after fade)"
		4 : "Fadeout" : 0 : "Fade OUT previous camera (time = waitmin)"
		8 : "Fadein" : 0 : "Fade IN this camera (time = waitmin2)"
	   16 : "Fixed Angle" : 0 : "All cameras in a chain will use the first camera angle"
	   32 : "End Camera" : 0 : "Only the fade in/out work, the origin/angle are ignored"
	]
	targetname(target_source) : "Name" : : "Camera name for linking into target chains."
	message(string) : "Message" : : "Text to centerprint when camera is viewed."
    message2(string) : "Message (coop warning)" : : "Text to centerprint if coop is active."
	target(target_destination) : "Target (next cam)" : : "Points to the next camera in a chain/sequence"
	target2(target_destination) : "Target2 (Starting of cinematic)" : : "Additional target(s) to trigger when camera is viewed"
	deathtarget(target_destination) : "Targets (Finishing of cinematic)" : : "Additional target(s) to trigger when the cinematic finishes."
	sounds(choices) : "Sound Style" = [ 
		1 : "Secret"
		2 : "Talk(def)"
		3 : "Switch"
		4 : "Silent"
		5 : "Custom"
		6 : "Secret2"
	]
	noise(sound): "Custom sound" : : "Sound to play when message is centerprinted."
	angles(integer) : "Direction the camera will face (Pitch Yaw Roll setup)"
	angletarget(target_destination) : "Direction the camera will face (using info_target)"
	focalpoint(choices) : "Camera Focal Point" : : "Always focus the camera on angletarget (=1 enabled)" = [
		 0 : "Default"
		1 : "angletarget "
	]
	angleblend(integer) : "Blend between current/last camera angles (def=0.03 range=0-1)"
	modeltarget(integer) : "Location of fake player mdl (use info_camera_destination)"
	returntarget(integer) : "Location of returning player (use info_camera_destination)"
	pos1(color255) : "Starting Background colour"
	pos2(color255) : "Finishing Background colour"
	waitmin(integer) : "Fade OUT prev cam (def=1s)" : : "Fade OUT time (def=1s, minimum=0.1s)"
	waitmin2(integer) : "Fade IN this cam (def=1s)" : : "Fade IN time (def=1s, minimum=0.1s)"
	sighttarget(target_destination) : "Position the camera will travel towards (use info_target)"
	waitmin3(integer) : "Speed at which camera moves towards sighttarget"
	wait(integer) : "Time to wait while showing camera (-1 = wait for key)"
	controltarget(integer) : "Bezier Curve control point (has angletarget defaults)"

	nodebuginfo(choices) :"Debug Info" : :  "All debug info displayed via developer=1 is blocked" = [
		 0 : "Default"
		 1 : "Block"
	]
]	
//_____WEATHER_____
@SolidClass base(AppearFlags,targetname) = misc_weather : "A BModel(brushwork) based particle emitter which produces weather effects" [
    spawnflags(Flags) = [ 
		8 : "Snow" : 0 : "White wispy flakes falling (def=rain)"
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
    count(integer) : "Quanity of Particles"
    pos1(string) : "Color Range (Min/Max/0)"
    pos2(string) : "Wind Direction (X/Y/Z(speed))"
    speed(integer) : "Random  Direction (-1=disable)"
]
//Common Settings for the next few Ent's
@baseclass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 8) 	color(0 128 200) = MiscSettings [
	spawnflags(Flags) = [ 64 : "Start Off" : 0 : "Starts off, waits for trigger" ] 
]
//_____FIREBALL_____
@PointClass base(MiscSettings) = misc_fireball : "Small Lava Balls, with damage on impact" [
	spawnflags(Flags) = [ 
		32 : "Slime" : 0 : "Green slime version (smoke trail)"
	]
	//Patch2 addition
	target(target_destination) : "Target (target an entity for custom direction)"
	speed(integer) : "Speed (def=1000)"
	dmg(integer) : "Impact Damage (def=5)"
	delay(integer) : "Spawn time (def=3)"
	wait(integer) : "Spawn time randomness (def=5)"
]
//_____AIR BUBBLES_____
@PointClass base(MiscSettings) = air_bubbles : "Sprite based bubble that floats upward" [
    style(choices) : "Style" = [
       1 : "Grey"
       2 : "Brown1"
       3 : "Blue1"
       4 : "Green1"
       5 : "Red1"
       6 : "Brown2"
       7 : "PinkYellow"
       8 : "Brown3"
       9 : "Purple1"
      10 : "Purple2"
      11 : "Brown4"
      12 : "Green2"
      13 : "Yellow"
      14 : "Blue2"
      15 : "Red2" 
	]
]
//_____DRIP_____
@PointClass base(MiscSettings) = misc_drip : "Falling water with splash and sound." [
	spawnflags(Flags) = [ 
		2 : "Silent" : 0 : "No drip sound (good for multiple drips)"
		16 : "Blood" : 0 : "Blood red drips"
		32 : "Slime" : 0 : "Slime green drips"
	]
	wait(integer) : "Random time between drips"
]
//_____SMOKE_____
@PointClass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 192) color(128 128 192) model({ "path": "progs/misc_smoke.mdl", "skin": exactskin }) = misc_smoke : "Smoke Model (DP only smoke particles (wait/delay/height DP only)). angles = 'pitch roll yaw' up/down, angle, tilt left/rightup/left = negative value, down/right = positive value" [
	spawnflags(Flags) = [
		 2 : "No DP Model" : 0 : "Do not draw smoke model in DP engine"
		 4 : "No DP Effects" : 0 : "Do not draw DP smoke particle effect"
		 8 : "No QS Model" : 0 : "Do not draw smoke model in QS/Fitz engine"
		64 : "Start Off" : 0 : "Starts off, waits for trigger"
	]
	target(string) : "Custom direction for smoke"
	angles(string) : "Pitch Roll Yaw"
	exactskin(choices) : "Smoke Style" = [
		0 : "Gunsmoke (Default)"
		1 : "Soot (darker)"
		2 : "Steam"
		3 : "Toxin"
		4 : "Plague"
		5 : "Incense"
		6 : "Lithium"
		7 : "Flames"
	]
	alpha(integer) : "Alpha of model (def=0.65)"
	wait(integer) : "DP Time between Spawning"
	delay(integer) : "DP Time randomness"
	height(integer) : "DP % of velocity direction"
]
//_____SPARK_____
@PointClass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 8) color(128 192 128) flags(Angle) = misc_spark : "Sparks - Produces a burst of sparks at random intervals. If targeting a light, it must start switched off (lights spawnflag=1)." [
	spawnflags(Flags) = [
		 2 : "Blue" : 0 : "Sparks are blue in colour (def=yellow)"
		 4 : "Pale White" : 0 : "sparks are pale yellow in colour (def=yellow)"
		 8 : "Red" : 0 : "sparks are red in colour (def=yellow)"
		64 : "Start Off" : 0 : "Starts off, waits for trigger"
	]
	target(string) : "Target a light to sync"
	wait(integer) : "Time delay between sparks(def=2)"
	cnt(integer) : "Quantity of sparks"
	fixangle(integer) : "1 = Random Y direction of sparks"
	speed(integer) : "Velocity speed (def=40)"
	height(integer) : "Velocity random (def=+/- 20)"
	sounds(choices) : "Sounds" = [
		1 : "Sparks"
		4 : "Silent"
		5 : "Custom"
	]
	noise(sound) : "Custom sound for spark"
]
//_____SHAKE____
@PointClass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 8)	color(128 128 230) flags(Angle) = misc_shake : "Shaking - Shake players view and/or velocity around center of entity. Always starts off, requires triggers to activate." [
	spawnflags(Flags) = [ 2 : "Screen ONLY" : 0 : "Shakes the view, but player movement is not affected" ]
	count(integer) : "Radius of shake (def=200)"
	wait(integer) : "Duration of shake (def=2s)"
	dmg(integer) : "Strength at center (def=200)"
	sounds(integer) : "Sounds 1=Rumble(no def)"
	noise1(sound) : "Custom Sound - Start"
	noise2(sound) : "Custom Sound - Finish"
]
//_____Misc MODEL_____
@PointClass base(AppearFlags, targetname) size(-16 -16 -16, 16 16 16) color(255 128 64) model({ 
	"path": mdl,
	// "skin": pos2,
    "skin": __show_skin,
    //"frame": pos1
    "frame": __show_frame
}) = misc_model : "Misc Models - Load custom models(.MDL files), as props, that are not predefined in the base game/mod. They can be setup with specific frame/skin and animation groups. Note - Having knowledge of at least opening/viewing '.mdl' files(ex QME) is recommended if customizing the settings." [
	spawnflags(Flags) = [
		 2 : "Collison" : 0 : "Model bbox collision enabled"
		 4 : "Moveable" : 0 : "Model can be moved around like an item"
	   32 : "Static" : 0 : "Makes entity static upon spawn (frame 0)"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	target(string) : "Path_corner entities to start moving towards on spawn"
	faceangle(integer) : "Set to 1 to rotate the model towards it's destination path_corner"
	yaw_speed(integer) : "Turning speed of model twowards path_corner if using faceangle=1 (def=15)"
	movespeed(integer) : "Movement (map units) per second towards path_corners if using faceangle=1 (def=50)"
	speed(integer) : "Override for frame/skin animation speed (def=0.1s)"
	mdl(string) : "Model Selection (ex progs/model.mdl)"
	angle(integer) : "facing angle of model (-1 = random position)"
	ideal_yaw(choices) : "Random Rotation (Y axis)" = [
		0 : "OFF(def)"
		1 : "Enabled"
	]
	angles(string) : "'pitch yaw roll' up/down, angle, tilt left/right" : : "up/down, angle, tilt left/right"
	frame(integer) : "exact frame number (Quoth entity compatibility)"
	framestart(integer) : "FRAME Starting point, 0=def, X=-1 Random, X=0+ Exact"
	frameloop(integer) : "FRAME type, 0=Constant, 1+=Range+stop, -1=Toggle, -2=Trigger+wait"
	skin(string) : "exact skin number (Quoth entity compatibility)"
	skinstart(string) : "SKIN Starting point, 0=def, X=-1 Random, X=0+ Exact"
	skinloop(string) : "SKIN type, 0=Constant, 1+=Range+stop, -1=Toggle, -2=Trigger+wait"
	mangle(string) : "'pitch yaw roll' override (Quoth entity compatibility)"
	alphastart(integer) : "ALPHA fade IN time for misc_model (1=Fade in over 1s)"
	bbmins(integer) : "Model bounding box override (only works with collision)"
	bbmaxs(integer) : "Model bounding box override"
	view_ofs (integer) : "Extra offset for origin (ideal for light origin issues)"
	delay(integer) : "Spawning delay for models on func movers (works once)"
	sounds(integer) : "TRIGGER 1=Secret, 2=talk, 3=switch, 4=silent, 5=custom, 6=secret2"
	locksounds(integer) : "TOGGLE 1=laser, 2=power, 4=silent, 5=custom"
	noise(string) : "Custom sound to play with animation TRIGGER"
	noise1(string) : "Custom sound to play when animation TOGGLE ON"
	noise2(string) : "Custom sound to play when animation TOGGLE OFF"
	volume(integer) : "Volume for all custom sounds played (def=1, range=0-1)"
	lip(integer) : "Frame/skin animation direction -2=random, -1=back, 1=forward(def)"
	state(integer) : "Automatic start of frame/skin animations (0=ON, -1/1=OFF)"
	rotateloop(integer) : "ROTATE type, 0=Constant, 1+=Range+stop, -1=Toggle, -2=Trigger+wait"
	rotateangles(integer) : "ROTATE axis (XYZ) changing (+/-) angles over time"

	//Testing frame selection/display		
	pos1(string) : "Frame Selection" : : "X=0, Y=0, Z=exact frame number, X->Y, Z=0 | will randomly pick a frame from the X,Y range, X->Y, Z=-1 | will animate between the X,Y range, can forward or backward setup."
	__show_frame(integer) : "Editor only! Display a single frame, use ps1 to setup frames used in-game"
	//Testing skin selection/display
	pos2(string) : "Skin Selection" : : "X=0, Y=0, Z=exact skin number, X->Y, Z=0 | will randomly pick a skin from the X,Y range."
	__show_skin(integer) : "Editor only! Display a specific skin, use pos2 to setup the skin used in-game"
]
//socks 'radiant gtk model entry
@PointClass base(AppearFlags, targetname) size(-16 -16 -16, 16 16 16) color(255 128 64) model({ 
    "path": mdl,
    "skin": pos2,
    "frame": pos1
}) = misc_gtkmodel : "Misc Models - MDL files that can be setup with specific frame/skin and animate groups." [
	spawnflags(Flags) = [
		 2 : "Collison" : 0 : "Model bbox collision enabled"
		 4 : "Moveable" : 0 : "Model can be moved around like an item"
	   32 : "Statue" : 0 : "Turn entity into static upon spawn (frame 0)"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	mdl(string) : "Model to load (progs/model.mdl)"
	angle(integer) : "facing angle"
	angles(string) : "pitch roll yaw" : : "up/down, angle, tilt left/right "
	ideal_yaw(choices) : "Y axis rotation" = [
		0 : "No rotation"
		1 : "Random"
	]
	pos1(string) : "Frame Selection" : : "X=0, Y=0, Z=exact frame number, X->Y, Z=0 | will randomly pick a frame from the X,Y range, X->Y, Z=-1 | will animate between the X,Y range, can forward or backward setup."
	pos2(string) : "Skin Selection" : : "X=0, Y=0, Z=exact skin number, X->Y, Z=0 | will randomly pick a skin from the X,Y range."
	speed(integer) : "Override for frame animation speed (def=0.1s)"
	lip(choices) : "Frame animation direction" = [
		-2 : "Random"
		-1 : "Backwards"
		1 : "Forward (default)"
	]
]
@PointClass base(AppearFlags, targetname) size(-16 -16 -16, 16 16 16) color(255 128 64) model({ 
    "path": mdl,
    "skin": pos2,
    "frame": pos1
	}) = mapobject_custom : "This is a duplicate of misc_model for quoth map compatibility" []
//_____Player POSED_____
@PointClass base(AppearFlags, targetname) size(-16 -16 -24, 16 16 32) color(255 128 64) model({"path": "progs/player.mdl", "frame": frame, "skin": exactskin}) = misc_player : "Misc Player - Dead Player MDL for poses." [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
//removing these for now, there is a key for them... easier setup
	//spawnflags(Flags) = [ 
	 //   1 : "On Back" : 0 
	  //  2 : "Face Down1" : 0
	   // 4 : "Slumped Over" : 0
	    //8 : "Face Down2" : 0
	   //16 : "Face Down3" : 0
	  // 32 : "On Side" : 0
	//]
	angle(integer) : "facing angle"
	ideal_yaw(choices) : "Y axis rotation" = [
		0 : "No rotation"
		1 : "Random"
	]
	frame(choices) : "Pose Selection(0 -> 143)"  = [
		49 : "On Back"
		60 : "Face Down 1"
		67 : "Slumped Over 1"
		69 : "Slumped Over 2"
		84 : "Face Down 2"
		93 : "Face Down 3"
	  102 : "On Side"
	      0 : "Type your own here!"
	]
	exactskin(choices) : "Skin Selection" = [
	   -1 : "Random"
		0 : "Default"
		1 : "Default + Blood"
		2 : "Green Armour"
		3 : "Green + Blood"
		4 : "Yellow Armour"
		5 : "Yellow + Blood"
		6 : "Red Armour"
		7 : "Red + Blood"
	]
	bodyonflrtrig(target_destination) : "Target - triggered when gibbed(Shadow Axe)"
]
//_____Demon POSED_____
@PointClass base(AppearFlags,targetname) size(-32 -32 -24, 32 32 64) color(255 128 64) model({ "path": "progs/mon_demon.mdl", "skin": exactskin, "frame": 53 }) = misc_demon : "Misc Demon - Dead demon/fiend for poses." [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	angle(integer) : "Facing Angle"
	ideal_yaw(choices) : "Y axis rotation" = [
		0 : "No rotation"
		1 : "Random"
	]
	exactskin(choices) : "Skin Selection" = [
	   -1 : "Random"
		0 : "Default"
		1 : "Green"
	]
	bodyonflrtrig(target_destination) : "Target - triggered when gibbed(Shadow Axe)"
]
//_____Death Knight POSED_____
@PointClass base(AppearFlags, targetname) size(-16 -16 -24, 16 16 40) color(192 64 0) model({ "path": "progs/mon_dknight.mdl", "frame":  frame }) = misc_dknight : "Misc Death Knight - Dead Death Knight for poses." [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	angle(integer) : "facing angle"
	ideal_yaw(choices) : "Y axis rotation" = [
		0 : "No rotation"
		1 : "Random"
	]
	frame(choices) : "Pose Selection" = [
		0 : "Type your own (0-<243)"
		223 : "On Front"
		243 : "On Back"
	]
	bodyonflrtrig(target_destination) : "Target - triggered when gibbed(Shadow Axe)"
]
//Patch2 additions
//angle  : facing angle (-1 = random position)
//angles : 'pitch yaw roll' up/down, angle, tilt left/right 
//ideal_yaw : = 1 Setup model with random Y axis rotation

//Corpse Common Settings
@baseclass base(AppearFlags,targetname,target) color(255 128 64) = CorpseCommonSettings [
	spawnflags(flags) = [ 64 : "Start OFF" : 0 : "Starts off, waits for trigger" ]
	angle(integer) : "Facing Angle(-1 (random)"
	ideal_yaw(choices) : "Y Axis Rotation(1 (random)" = [
		0 : "No rotation"
		1 : "Random"
	]
	angles(string) : "pitch yaw roll' up/down, angle, tilt left/right" 
]
//_____Corpse(s) POSED_____
//crucified
@PointClass base(CorpseCommonSettings) size(-16 -16 -24, 16 16 40) model({ "path": "progs/corpse_imp.mdl", "frame": 9, "skin": 7 }) = corpse_crucified1 : "Corpse model(crucified)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -24, 16 16 40)  model({ "path": "progs/corpse_imp.mdl", "frame": 10, "skin": 8 }) = corpse_crucified2 : "Corpse model (crucified + headless)" []
//impaled
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 0) model({ "path": "progs/corpse_imp.mdl", "frame": 0, "skin": 0 }) = corpse_impaled_back1 : "Corpse model (impaled in back + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 0) model({ "path": "progs/corpse_imp.mdl", "frame": 0, "skin": 1 }) = corpse_impaled_back2 : "Corpse model (impaled in back)" [] 
@PointClass base(CorpseCommonSettings) size(-16 -16 -24, 16 16 0) model({ "path": "progs/corpse_imp.mdl", "frame": 1, "skin": 2 }) = corpse_impaled_back3 : "Corpse model (impaled in back + eaten)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -16, 16 16 16) model({ "path": "progs/corpse_imp.mdl", "frame": 2, "skin": 0 }) = corpse_impaled_front1 : "Corpse model (impaled in front + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -16, 16 16 16) model({ "path": "progs/corpse_imp.mdl", "frame": 2, "skin": 1 }) = corpse_impaled_front2 : "Corpse model (impaled in front)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -8, 16 16 16) model({ "path": "progs/corpse_imp.mdl", "frame": 3, "skin": 3 }) = corpse_impaled_front3 : "Corpse model (impaled in front + eaten)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -40, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 4, "skin": 0 }) = corpse_impaled_horizontal1 : "Corpse model (impaled horizontal + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -40, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 4, "skin": 1 }) = corpse_impaled_horizontal2 : "Corpse model (impaled horizontal)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -40, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 5, "skin": 4 }) = corpse_impaled_horizontal3 : "Corpse model (impaled horizontal + nibbled)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 16) model({ "path": "progs/corpse_imp.mdl", "frame": 6, "skin": 5 }) = corpse_impaled_horizontal4 : "Corpse model (impaled horizontal + eaten)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 7, "skin": 0 }) = corpse_impaled_vertical1 : "Corpse model (impaled vertical + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 7, "skin": 1 }) = corpse_impaled_vertical2 : "Corpse model (impaled vertical)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -32, 16 16 24) model({ "path": "progs/corpse_imp.mdl", "frame": 8, "skin": 6 }) = corpse_impaled_vertical3 : "Corpse model (impaled vertical + eaten)" []
//lynched
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_lynch.mdl", "frame": 0, "skin": 0 }) = corpse_lynched1 : "Corpse model (lynched + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_lynch.mdl", "frame": 0, "skin": 1 }) = corpse_lynched2 : "Corpse model (lynched)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_lynch.mdl", "frame": 1, "skin": 2 }) = corpse_lynched3 : "Corpse model (lynched + eaten)" []
//flayed
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_flay.mdl", "frame": 0, "skin": 0 }) = corpse_flayed1 : "Corpse model (flayed + clothed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_flay.mdl", "frame": 0, "skin": 1 }) = corpse_flayed2 : "Corpse model (flayed)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_flay.mdl", "frame": 2, "skin": 2 }) = corpse_flayed3 : "Corpse model (flayed + eaten)" []
@PointClass base(CorpseCommonSettings) size(-16 -16 -96, 16 16 0) model({ "path": "progs/corpse_flay.mdl", "frame": 1, "skin": 1 }) = corpse_flayed4 : "Corpse model (flayed + broken leg)" []
//____EXPLODING BOX(2)_____
//----- Explobox(2) Common Settings
@baseclass base(AppearFlags,targetname,target) color(0 128 192) = ExploBoxSettings [
	spawnflags(Flags) = [
		32 : "Floating" : 0: "No drop to floor test"
		64 : "Start Off" : 0 : "Starts off, waits for trigger"
	]
	skin_override(choices) : "Skin Type (animated)" : : "Choose an animated skin, like health packs." = [
		0 : "Original ID (def)"
		1 : "Rubicon2"
		2 : "Plasma"
		3 : "Toxic"
		4 : "Light wood"
		5 : "Dark wood"
		
	]
	noise(sound) : "Custom Sound" :  : "Explosion(def=weapons/r_exp3.wav)"
	health(integer) : "Health (def=15)"
	dmg(integer) : "Radius Damage (def=160)"
]
@PointClass base(ExploBoxSettings) size(-16 -16 0, 16 16 64) color(0 128 200) model({{
		skin_override == 1 ->	{"path": "progs/explode_box1.mdl", "skin": 2},
		skin_override == 2 -> 	{"path": "progs/explode_box1.mdl", "skin": 4},
		skin_override == 3 -> 	{"path": "progs/explode_box1.mdl", "skin": 6},
		skin_override == 4 -> 	{"path": "progs/explode_box1.mdl", "skin": 8},
		skin_override == 5 ->	{"path": "progs/explode_box1.mdl", "skin": 10},
														"progs/explode_box1.mdl"
}}) = misc_explobox : "Large box" []
@PointClass base(ExploBoxSettings) size(-16 -16 0, 16 16 32) color(0 128 200)  model({{
		skin_override == 1 ->	{"path": "progs/explode_box2.mdl", "skin": 2},
		skin_override == 2 -> 	{"path": "progs/explode_box2.mdl", "skin": 4},
		skin_override == 3 -> 	{"path": "progs/explode_box2.mdl", "skin": 6},
		skin_override == 4 -> 	{"path": "progs/explode_box2.mdl", "skin": 8},
		skin_override == 5 ->	{"path": "progs/explode_box2.mdl", "skin": 10},
														"progs/explode_box2.mdl"
}}) = misc_explobox2 : "Small box" []
//_____TEXT BOOK_____
@PointClass base(AppearFlags, targetname, target, target2) size(-16 -16 -8, 16 16 8) color(0 128 128) flags(Angle) = misc_textbook : "Misc Text Books - Display custom text messages." [
	spawnflags(Flags) = [
		 1 : "No Model + Effects" : 0 : "Will not use book model + particles"
		 2 : "Plinth1" : 0 : "Setup book on top of plinth1 model"
		 4 : "Plinth2" : 0 : "Setup book on top of plinth2 model"
		 8 : "StoryLine" : 0 : "Book is part of a story (use target2)"
		16 : "Plinth Collision" : 0 : "Use bounding box collision for plinth"
		32 : "Facing Angle Only" : 0 : "Will only work when standing infront of entity (angle key)"
		64 : "Start Off" : 0 : "Starts OFF, waits for trigger"
		128: "No Effects" : 0 : "No particle or effects active"
	]
	v_angle(string) : "Viewing angle (def='30 60 0')"
	exactskin(choices) : "Book Cover" = [
		0 : "Brown 1"
		1 : "Brown 2"
		2 : "Green 1"
		3 : "Green 2"
		4 : "Blue 1"
		5 : "Blue 2"
		6 : "Red 1"
		7 : "Red 2"
	]
	randomskin(integer) : "Random Skin (range = 1-randomskin)"
	pos1(string) : "Touch trigger minimum size(def=-48 -48 -32)"
	pos2(string) : "Touch trigger maximum size(def=48 48 32)"
	message(string) : "Header message"
	message2(string) : "Body text 1(need to add linefeeds)"
	message3(string) : "Body text 2(displayed after message2)"
	message4(string) : "Body text 3(displayed after message3)"
]
//_____TEXT STORY_____
@PointClass base(AppearFlags, targetname, target) size(-16 -16 -8, 16 16 8) color(0 128 255) flags(Angle) = misc_textstory : "Misc Text Story - Text Book Story Chapters." [
	message(string) : "Header message"
	message2(string) : "Body text 1(need to add linefeeds)"
	message3(string) : "Body text 2(displayed after message2)"
	message4(string) : "Body text 3(displayed after message3)"
]
//_____STORY CONTROLLER_____
@PointClass base(AppearFlags) size(-16 -16 -8, 16 16 8) color(0 25 255) flags(Angle) = misc_textstoryctrl : "Misc Story Controller - Text Book Story Controller" [
	targetname(target_source)  : "Name (of controller for story)"
	target(target_destination) : "Chapter 1 (name of first chapter)"	
]
//_____MISC BOB_____
@PointClass base(AppearFlags, targetname) size(-16 -16 -16, 16 16 16) color(255 128 64) model( {"path":  mdl} ) = misc_bob : "Bobbing models - An externally defined model that gently moves back and forth." [
    spawnflags(Flags) = [
        2 : "Collision" : 0 : "model bbox collision enabled"
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger"
    ]    
    mdl(string) : "Model (ex. progs/candle.mdl)"
    angle(integer) : "Direction (use 360 for 0)"
	height(integer) : "Direction Intensity (def=4)"
	count(integer) : "Cycle timer (def=2, min=1)"
	waitmin(integer) : "Speed up scale (def=1)"
	waitmin2(integer) : "Slow down scale (def=0.75)"
	delay(integer) : "Delay start (def=0, -1=random)"
]
//_____TARGET DUMMY_____
@PointClass size(-32 -32 -24, 32 32 64) color(0 128 128) flags(Angle) = misc_targetdummy : "Misc target Dummies" [
	spawnflags(Flags) = [
		 1 : "Knight" : 0 : "Knight model"
		 2 : "Wizard" : 0 : "Wizard model"
		 4 : "Ogre" : 0 : "Orge model"
		 8 : "Hell Knight" : 0 : "Hell Knight model"
		16 : "Zombie" : 0 : "Zombie model"
		32 : "Demon" : 0 : "Demon model"
		64 : "Shalrath" : 0 : "Vore model"
		128: "Shambler" : 0 : "Shambler model"
	]
	noise1(string) : "targetnumber tracking weapon used"
	noise2(string) : "targetnumber tracking enemy distance"
	noise3(string) : "targetnumber tracking damage"
	noise4(string) : "targetnumber tracking % efficency"
	wait(integer) : "Impact marker removal time"
]
//_____INGAME NUMBERS_____
@PointClass base(targetname) size(-4 -4 -8, 4 4 8) color(128 128 0) flags(Angle) = misc_targetnumber : "Ingame numbers - target damage numbers to display ingame." [
	mdl(string) : "Numbers 0-9,dot,blank (def=progs/misc_digit.mdl)"
	waitmin(integer) : "Spacing of the model numbers (def=8)"
	pos1(string) : "X=top digits (max 4), Y=lower digits (max 3)"
	cnt(integer) : "Initial display value on spawn (must be >0)"
]

//======================================================================
//
// TRAP entities
//
//======================================================================

//_____Trap Common Settings_____
@baseclass base(AppearFlags, targetname, target) size(-8 -8 -8, 8 8 8) color(0 128 200) flags(Angle) = Trap [
	spawnflags(Flags) = [ 
		32 : "Toggle" : 0 : "Trigger will toggle the shooter on/off instead"
		128 : "Tracking" : 0 : "Will update target entity origin before firing"
	]	
]
//_____SPIKE SHOOTER_____
@PointClass base(Trap) = trap_spikeshooter : "Spike Shooter - When triggered, fires a SPIKE in the direction determined by angle. Use TOGGLE spawnflag and trigger to enable continuous mode." [
	spawnflags(Flags) = [
		1 : "SNG Spike" : 0 : "Shoots large spike (SNG damage)"
		2 : "Laser" : 0 : "Shoots laser (Enforcer damage)"
		4 : "Wizard" : 0 : "Shoots acid spike (Wizard damage)" 
		8 : "Hell Knight" : 0 : "Shoots fire spike (Hell Knight damage)"
	]
	angle(integer) : "Direction (firing), use '360' for angle 0"
	wait(integer)  : "time between firing (def=1s)"
	delay(integer) : "random time between firing"
	speed(integer) : "Projectile speed"	
]
//_____GRENADE SHOOTER_____
@PointClass base(Trap) = trap_grenadeshooter : "Grenade Shooter - When triggered, fires a GRENADE in the direction determined by angle. Use TOGGLE spawnflag and trigger to enable continuous mode." [
	spawnflags(Flags) = [ 1 : "Large" : 0 : "Shoots high damage grenade (Player damage, def=ogre)" ]
	angle(integer) : "Direction (firing), use '360' for angle 0"
	wait(integer) : "time between firing (def=1s)"
	delay(integer) : "random time between firing"
	speed(integer) : "Projectile speed"
]
//_____ROCKET SHOOTER_____
@PointClass base(Trap) = trap_rocketshooter : "Rocket Shooter - When triggered, fires a ROCKET in the direction determined by angle. Use TOGGLE spawnflag and trigger to enable continuous mode." [
	spawnflags(Flags) = [
		1 : "Lava" : 0 : "Shoots Chthon lava ball (Player damage)"
		2 : "Fireball" : 0 : "Shoots Gargoyle fire ball (low damage)"
		4 : "Jim" : 0 : "Shoots Jim rocket (low damage)"	
	]
	angle(integer) : "Direction (firing), use '360' for angle 0"
	wait(integer) : "time between firing (def=1s)"
	delay(integer) : "random time between firing"
	speed(integer) : "Projectile speed"
]
//_____LIGHTNING SHOOTER_____
@PointClass base(Trap) = trap_lightningshooter : "Lightning Shooter - When triggered, fires a LIGHTNING at the target entity (can be blocked). Use TOGGLE spawnflag and trigger to enable continuous mode." [
	spawnflags(Flags) = [
		1 : "Large" : 0 : "Chthon Boss Lightning"
		8 : "Dust" : 0 : "Produce dust/smoke at point of impact"
	   16 : "Particles" : 0 : "Produce particles at point of impact"
	]
	wait(integer) : "time between firing (def=1s)"
	delay(integer) : "random time between firing"
	volume(integer) : "Sound volume (def=0.75)"
	pos1(string) : "random XYZ wobble to source"
	pos2(string) : "random XYZ wobble to target"
]
//_____GAS SHOOTER_____
@PointClass base(Trap) = trap_gasshooter : "Particle Shooter" [
	spawnflags(Flags) = [ 
		1 : "Steam" : 0 : "White hot clouds of steam (default)" 
		2 : "Fire" : 0 : "Will add burning debuff to player"
		4 : "Poison" : 0 : "Will add poison debuff to player"
	   16 : "Silent" : 0 : "No on/off sound, its silent!"
	]
	angle(integer) : "Direction (firing), use '360' for angle 0"
	wait(integer) : "Spawn time delay (def=0.05s)"
	speed(integer) : "Velocity speed (def=200)"
	waitmin(integer) : "Auto switch off timer (def=0.5s)"
	dmg(integer) : "Touch Damage (def=1)"
]
//_____PENDULUM_____
@baseclass base(AppearFlags, targetname) color(0 128 200 ) = Trap_Pendulum [
	spawnflags(Flags) = [
		1 : "Reverse" : 0 : "Start at frame 12 instead of 0"
		2 : "One Swing" : 0 : "Swing back & forth and then stop"
	   64 : "Start OFF" : 0: "Starts off, waits for trigger"
	]
	dmg(integer) : "Touch Damage (def=5)"
	waitmin(integer) : "Time between Touch Damage (def=0.5s)"
	wait(integer) : "Starting Delay"
]
@PointClass base(Trap_Pendulum) size(-8 -192 -24, 8 0 24) model("progs/trap_pendlong.mdl") = trap_pendlong : "Long Pendulum" []
@PointClass base(Trap_Pendulum) size(-192 -8 -24, 0 8 24) model("progs/trap_pendlong.mdl") = trap_pendlongx : "Long Pendulum X Axis" []
@PointClass base(Trap_Pendulum) size(-8 -128 -24, 8 0 24) model("progs/trap_pendshort.mdl") = trap_pendshort : "Short Pendulum" []
@PointClass base(Trap_Pendulum) size(-128 -8 -24, 0 8 24) model("progs/trap_pendshort.mdl") = trap_pendshortx : "Short Pendulum X Axis" []
//_____SAW BLADE_____
@baseclass base(AppearFlags, targetname, target) = Trap_SawBlade [
	spawnflags(Flags) = [
		1  : "Start ON" : 0 : "Start moving straight away if targetname is used"
		32 : "Reverse" : 0 : "Start at frame 12 instead of 0"
		64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	speed(integer) : "Speed Travel (def=100)"
	yaw_speed(integer) : "Speed Rotation (def=180)"
	dmg(integer) : "Touch Damage (def=4)"
	waitmin(integer) : "Damage pause ON state (def=0.1s)"
	height(integer) : "Damage pause OFF state (def=1s)"
	lip(choices) : "Deceleration time" = [
		-1 : "Instant Stop"
		 2 : "Default"
	]
	sounds(choices) : "Sounds" = [
		0 : "Silent (def)"
		1 : "Woodmill"
		5 : "Custom"
	]
	noise(sound) : "Custom Sound - Stopping"
	noise1(sound) : "Custom Sound(Looped) - Moving"
]
@PointClass base(Trap_SawBlade) size(-4 -32 -32, 4 32 32) model("progs/trap_sawblade.mdl") = trap_sawbladey : "Saw Blade on Y axis" []
@PointClass base(Trap_SawBlade) size(-32 -4 -32, 32 4 32) model("progs/trap_sawblade.mdl") = trap_sawbladex : "Saw Blade on X axis" []

//======================================================================
//
// LIGHT entities
//
//======================================================================
//Patch2 additions
//styles 12-31 can be custom in map (use customlightstyle)
//styles 32-62 are assigned by the light program for switchable lights

//can define custom light styles for switchable lights
//or
//define new light styles (12-31)//UPDATE://styles 01-63 can be custom in map (use customstyle_string)//styles 32-63 are assigned by the light program for switchable lights//customstyle_remap  : Re-use another light style (0-63)//customstyle_string : light value string made up of "a-z" letters
//_____Common *Light Settings_____
@baseclass base(targetname,target) = Light [
	light(integer) : "Brightness" :  : "Set the light intensity. Negative values are also allowed and will cause the entity to subtract light cast by other entities. Default 300"
	_color(color255) : "Color" :  : "Specify RGB values for the color of the light. Default is white(255 255 255)"
	style(choices) : "Appearance" = [
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]	//ISSUE//Until I get  a new progs will use old key names//customstyle_remap  : Re-use another light style (0-63)		
	customlighttype(integer)  : "Style Remap" : : "Use original (0-11) values as string or define new one"//customstyle_string 	light value string made up of "a-z" letters
	customlightstyle(string) : "Style Definition" : : "light value string made up of 'a-z' letters"	
	delay(choices) : "Attenuation" :  : "Select an attenuation formula for the light: 0 = Linear attenuation (default). 1 = 1/x attenuation. 2 = 1/(x^2) attenuation. 3 = No attenuation (same brightness at any distance). 4 = 'local minlight' - No attenuation and like minlight, it won't raise the lighting above it's light value. Unlike minlight, it will only affect surfaces within line of sight of the entity. 5 = 1/(x^2) attenuation, but slightly more attenuated and without the extra bright effect that 'delay 2' has near the source"  = [
		0 : "Linear falloff (Default)"
		1 : "Inverse distance falloff"
		2 : "Inverse distance squared"
		3 : "No falloff"
		4 : "Local minlight"
		5 : "Inverse distance 2"
	]
	wait(integer) : "Fade distance multiplier" :  : "Scale the fade distance of the light by 'n'. Values of n more than 1 make the light fade more quickly with distance, and values less than 1 make the light fade more slowly (and thus reach further). Default 1"
	
	_falloff(integer) : "Falloff(in map units)" :  : "Sets the distance at which the light drops to 0, in map units."

//------------------- Alternate Spotlight Method and Options --------------------------

//----- Alternate Spotlight -----
	
	mangle(string) : "Spotlight direction" :  : "Turns the light into a spotlight and specifies the direction of light using yaw(x), pitch(y) and roll(z) in degrees. Yaw specifies the angle around the Z-axis(0 - 359) and pitch specifies the angle from 90 (straight up) to -90 (straight down). Roll has no effect, use 0."
	angle(integer) : "Spotlight cone angle" :  : "Specifies the angle in degrees for a spotlight cone. Default 40"
	_softangle(integer) : "Spotlight soft angle" :  : "Specifies the angle in degrees for an inner spotlight cone (must be less than the 'angle' cone. Creates a softer transition between the full brightness of the inner cone to the edge of the outer cone. Default 0 (disabled)."

//------------------- Dirt Options and Overrides --------------------------

//----- Dirt Options -----
	
	_dirt(integer) : "Dirt map (override)" :  : "Overrides the worldspawn setting of '_dirt' for this particular light. -1 to disable dirtmapping (ambient occlusion) for this light, making it illuminate the dirtmapping shadows. 1 to enable ambient occlusion for this light. Default is to defer to the worldspawn setting"
	_dirtscale(integer) : "Dirt scale (override)" :  : "Override the global '_dirtscale' or '_dirtgain' settings to change how this light is affected by dirtmapping (ambient occlusion). See descriptions of these keys in the worldspawn section"
	
//------------------- Advanced Light Options --------------------------

//----- Advanced Options -----
	
    _anglescale(integer) : "Light angle scale" :  : "Sets a scaling factor for how much influence the angle of incidence of light on a surface has on the brightness of the surface. n must be between 0.0 and 1.0. Smaller values mean less attenuation, with zero meaning that angle of incidence has no effect at all on the brightness. Default 0.5"
    _bouncescale(integer) : "Bounce Scale" :  : "Scales the amount of light that is contributed by bounces. Default is 1.0, 0.0 disables bounce lighting for this light."	
	_deviance(integer) : "Deviance" :  : "Split up the light into a sphere of randomly positioned lights within radius 'n' (in world units). Useful to give shadows a wider penumbra. '_samples' specifies the number of lights in the sphere. The 'light' value is automatically scaled down for most lighting formulas (except linear and non-additive minlight) to attempt to keep the brightness equal. Default is 0, do not split up lights"
	_samples(integer) : "No. of Deviance lights" :  : "Number of lights to use for '_deviance'. Default 16 (only used if '_deviance' is set)"	

]
// -------- Base Class for point entity Light ONLY features --------------
@baseclass = PointEntityOnly [

//----- Texture Options -----
    
    _surface(string) : "Surface light texture name" :  : "Makes surfaces with the given texture name emit light, by using this light as a template which is copied across those surfaces. Lights are spaced about 128 units (though possibly closer due to bsp splitting) apart and positioned 2 units above the surfaces."
	_surface_offset(integer) : "Surface light offset" :  : "Controls the offset lights are placed above surfaces for '_surface'. Default 2"

   _surface_spotlight(integer) : "Surface Spotlight" :  : "For a surface light template (i.e. a light with '_surface' set), setting this to 1 makes each instance into a spotlight, with the direction of light pointing along the surface normal. In other words, it automatically sets 'mangle' on each of the generated lights."

    _project_texture(string) : "Project Texture(name)" :  : "Specifies that a light should project the named texture. The texture must be used in the map somewhere."

    _project_mangle(string) : "Projection Mangle" :  : "Specifies the yaw/pitch/roll angles for a texture projection (overriding mangle)."

    _project_fov(integer) : "Projection FOV" :  : "Specifies the 'Field of View'(FOV) angle for a texture projection. Default 90."

//------------------- Alternate SUN Method --------------------------

//----- USE as a SUN -----

    _sun(choices) : "Sun" :  : "Set to 1 to make this entity a sun, as an alternative to using the sunlight worldspawn keys. If the light targets an 'info_null' entity, the direction towards that entity sets sun direction. The light itself is disabled, so it can be placed anywhere in the map." = [
    0 : "Default(OFF)"
    1 : "USE as a Sun"
  ]
]
// -------- END  of Base Class for point entity Light ONLY features -----------

@baseclass base(Light) = LightPoint [] 
@baseclass base(Light) = LightTorch []
@baseclass base(Light) offset(0 0 12) = LightFlame []
@baseclass = LightOFF [ spawnflags(flags) = [ 1 : "Start Off" : 0 : "Starts OFF, waits for trigger." ] ]

//______LIGHT_____ 
@PointClass base(LightPoint, PointEntityOnly, LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) offset(0 0 8) iconsprite("sprites/light.spr") = light : "Invisible lightsource" []
@PointClass base(LightPoint,LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) iconsprite("sprites/light.spr") = light_fluoro : "Fluorescent light" [
	spawnflags(flags) = [
		2 : "No Sound" : 0 : "No ambient sound"
	]
]
//______FLUORESCENT_____
@PointClass base(LightPoint,LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) iconsprite("sprites/light.spr") = light_fluorospark : "Sparking fluorescent light" [
	spawnflags(flags) = [
		2 : "No Sound" : 0 : "No ambient sound"
	]
]
//_____GLOBE_____
@PointClass base(LightPoint,LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) sprite("progs/s_light.spr") = light_globe : "Globe light" [
	spawnflags(flags) = [
		4 : "No Static" : 0 : "Will not turn into static entity"
	]
]
//_____SMALL WALL TORCH_____
@PointClass base(LightTorch,LightOFF) size(-10 -10 -20, 10 10 20) color(230 230 0) model("progs/flame.mdl") = light_torch_small_walltorch : "Small walltorch" [
	spawnflags(flags) = [
		2 : "No Sound" : 0 : "No ambient sound" 
		4 : "No Static" : 0 : "Will not turn into static entity"
	128 : "No Particles" : 0 : "No particle or effects active"
	]
]
//_____SMALL YELLOW FLAME_____
@PointClass base(LightFlame,LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) model({ "path":"progs/flame2.mdl", "frame": 0 }) = light_flame_small_yellow : "Small yellow flame" [
	spawnflags(flags) = [
		2 : "No Sound" : 0 : "No ambient sound" 
		4 : "No Static" : 0 : "Will not turn into static entity"
	128 : "No Particles" : 0 : "No particle or effects active"
	]
]
//_____LARGE YELLOW FLAME_____
@PointClass base(LightFlame,LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) model({ "path":"progs/flame2.mdl", "frame": 1 })  = light_flame_large_yellow : "Large yellow flame" [
	spawnflags(flags) = [
		2 : "No Sound" : 0 : "No ambient sound" 
		4 : "No Static" : 0 : "Will not turn into static entity"
	128 : "No Particles" : 0 : "No particle or effects active"
	]
]
//_____CANDLE_____
@PointClass base(Light,LightOFF) size(-4 -4 -16, 4 4 16) color(230 230 0)  model({{

//======= HIGHLY experiMENTAL! =======
// candle3 is DEFAULT in game | 0, 2, 4 = flame off and  1, 3, 5 =flame on

	//short, thin, flame off/on
	((spawnflags & 2) != 0 && (height ) == 1) && (t_width) == 3 -> {"path": "progs/misc_candle1.mdl", "frame": 4},
	((height == 1) && (t_width == 3 )) -> {"path": "progs/misc_candle1.mdl", "frame": 5},
	//short, fat, flame off/on
	((spawnflags & 2) != 0 && (height ) == 1) && (t_width) == 2 -> {"path": "progs/misc_candle1.mdl", "frame": 2},
	((height == 1) && (t_width == 2 )) -> {"path": "progs/misc_candle1.mdl", "frame": 3},
	//short, flame off/on
	((spawnflags & 2) != 0 && (height ) == 1) && (t_width) <= 1 -> {"path": "progs/misc_candle1.mdl", "frame": 2},
	height == 1 -> 		{"path": "progs/misc_candle1.mdl", "frame": 1},

	//medium,thin, flame off/on
	((spawnflags & 2) != 0 && (height ) == 2) && (t_width) == 3 -> {"path": "progs/misc_candle2.mdl", "frame": 4},
	((height == 2) && (t_width == 3 )) -> {"path": "progs/misc_candle2.mdl", "frame": 5},
	//medium, fat, flame off/on
	((spawnflags & 2) != 0 && (height ) == 2) && (t_width) == 2 -> {"path": "progs/misc_candle2.mdl", "frame": 2},
	((height == 2) && (t_width == 2 )) -> {"path": "progs/misc_candle2.mdl", "frame": 3},
	//medium, flame off/on
	((spawnflags & 2) != 0 && (height ) == 2) && (t_width) <= 1 -> {"path": "progs/misc_candle2.mdl", "frame": 0},
	height == 2 ->		{"path": "progs/misc_candle2.mdl", "frame": 1},
	
	//regular,thin, flame off/on
	((spawnflags & 2) != 0 && (t_width) == 3 )-> {"path": "progs/misc_candle3.mdl", "frame": 4},
	t_width == 3 -> {"path": "progs/misc_candle3.mdl", "frame": 5},
	//regular, fat, flame off/on
	((spawnflags & 2) != 0 && (t_width) == 2) -> {"path": "progs/misc_candle3.mdl", "frame": 2},
	t_width == 2 -> 	{"path": "progs/misc_candle3.mdl", "frame": 3},
	//regular, flame off/on
	spawnflags & 2 -> {"path": "progs/misc_candle3.mdl", "frame": 0},
	spawnflags ^ 2 -> {"path": "progs/misc_candle3.mdl", "frame": 1}
											
	}}) = light_candle : "Church candle" [
	spawnflags(flags) = [
		2 : "Flame Off" : 0 : "The candle is displayed off (no flame)"
		8 : "DP Shadows" : 0 : "Turn on shadows in DP engine"
	]		
//----- MODEL Options -----

		height(choices) : "Candle Size" = [
		-1: "Random"
		//0 : "Default"
		1 : "Short"
		2 : "Medium"
		3 : "Regular (def)"
	]
	t_width(choices) : "Candle Width" = [
		-1: "Random"
		//0 : "Default"
		1 : "Regular (def)"
		2 : "Fat"
		3 : "Thin"
	]
	lip(integer) : "Move model down def=16"
]
//____ LIGHT - POST/TUBE/FIXTURE_____
@PointClass base(Light, LightOFF) size(-10 -10 -20, 10 10 20) color(230 230 0) model("progs/misc_lightpost.mdl") = light_postlight : "Light Post (from Quoth)" []
@PointClass base(Light, LightOFF) size(-10 -10 -20, 10 10 20) color(230 230 0) model("progs/misc_lighttube.mdl") = light_tubelight : "Light Tube (from Quoth)" []
@PointClass base(Light, LightOFF) size(-10 -10 -20, 10 10 20) color(230 230 0) model("progs/misc_fixture1.mdl") = light_fixture1 : "Light Fixture (from Rubicon)" [
	fixangle(integer) : "Angle of model"
]
//Patch2 additions
//____ LIGHT - PYRE/BRAZIER_____
@PointClass base(Light, LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) model("progs/misc_flame_big.mdl") = light_flame_pyre : "Flame Pyre (from Quoth)" [
	spawnflags(flags) = [
		64 : "No Particles" : 0 : "No particle or effects active"
	]		
]
@PointClass base(Light, LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) model({ "path": "progs/misc_brazshrt.mdl", "skin": skin }) = light_flame_brazier_short : "Short brazier (from Quoth)" [
	spawnflags(flags) = [
		64 : "No Particles" : 0 : "No particle or effects active"
	]
	skin(choices) : "Skin" = [
		0 : "Knave(def)" 
		1 : "Rust" 
		2 : "Redbrick" 
		3 : "Copper"
		4 : "Altar" 
		5 : "Wizmet"
	]			
]
@PointClass base(Light, LightOFF) size(-8 -8 -8, 8 8 8) color(230 230 0) model({ "path": "progs/misc_braztall.mdl", "skin": skin }) = light_flame_brazier_tall : "Long brazier (from Quoth)" [
	spawnflags(flags) = [
		64 : "No Particles" : 0 : "No particle or effects active"
	]
	skin(choices) : "Skin" = [
		0 : "Knave(def)" 
		1 : "Rust" 
		2 : "Redbrick" 
		3 : "Copper"
		4 : "Altar" 
		5 : "Wizmet"
	]			
]

//======================================================================
//
// HIPNOTIC/RITUAL ROTATION STUFF
//
//======================================================================

//_____HipBMODELSettings_____
@baseclass base(AppearFlags, targetname, target, FuncLighting) = HipBMODELSettings []

//_____INFO ROTATE_____
@PointClass base(targetname) size(-4 -4 -4, 4 4 4) color(0 128 0) = info_rotate : "Pivot point for rotating BModel(brushwork) objects. See 'rotate_object' or 'func_rotate_door' for use." []

//_____ROTATE ENTITY_____
@PointClass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 8) color(0 128 200) = func_rotate_entity : "The actual 'rotator' of toggleable 'spinning' BModel(brushwork) objects. See 'rotate_object' for use." [
	spawnflags(flags) = [
		1 : "Toggle" : 0 : "Rotation can be toggled on/off, 0 = cannot be turned off"
		2 : "Start ON" : 0 : "Entity is spinning when spawned"
		4 : "ZEROFIN" : 0 : "Always end at zero angles when finished"
		64 : "Start OFF" : 0 : "Entity starts off"
	]
	target(target_destination) : "Rotating origin point (use info_rotate)"
	targetname(target_source) : "trigger entity (works with entity state system)"
	rotate(integer) : "XYZ rate of rotation in degrees (speed(ex. 0 720 0)"
	speed(integer) : "Time in seconds to speed up/down object (def=0s)"
	yaw_speed(integer)  : "Alternative time to slowdown object (def=speed)"
	waitmin(integer) : "Time to wait before setup on spawn (def=0.1s)"
	sounds(choices) : "0 = silent, 1 = small industrial fan (def=0)" = [
		0 : "Silent"
		1 : "Small industrial fan" ]
	noise1(string) : "Custom sound - Spinning UP"
	noise2(string) : "Custom sound - Full Speed"
	noise3(string) : "Custom sound - Spinning DOWN"
	noise4(string) : "Custom sound - STOP sound"
]
//_____ROTATING OBJECT_____
@SolidClass base(HipBMODELSettings) = rotate_object : "A NON-SOLID BModel(Brushwork) object you want to spin/rotate. There are three parts required to rotate an object. A brush, which you turn into a 'rotate_object', and two point entities('info_rotate' + 'func_rotate_entity' or 'func_rotate_door'). BASIC Spinning Example - 1| Create a brush 64X64 in the Top(X/Y) area of JACK, 'tie it to entity>rotate>rotate_object' and name it 'Fan1' 2| Place an 'info_rotate' in the center, all planes, of that brush and name it 'Fan1_Pivot' 3| Go back to 'Fan1' and in 'target' select 'Fan1_Pivot' 4| Last but not least, place a 'rotate_entity' also dead center of 'Fan1'. Yes, it will hide the 'info_rotate'! Give it a 'name' of 'spin_Fan1', in target select 'Fan1', set a 'Rotation Rate' to (0 720 0) and set the spawnflag 'Start On'. You're all set, load up your map and watch it spin. If you uncheck 'Start On', then check 'Toggle', you can use your typical buttons/triggers to control the on/off state. You can also set a spin up/down time. **Doors(draw bridges etc) are similar but use the 'func_rotate_door' as the control entity coupled with the 'info_rotate', both placed at the point of rotation typical for a 'door'. NOTE - NON-SOLID means no collision, see func_movewall." [
	target(target_destination) : "Target (info_rotate entity)."
]
//_____PATH ROTATE_____
@PointClass base(AppearFlags, targetname, target) size(-8 -8 -8, 8 8 8) color(255 128 0) = path_rotate : "Path corner WITH rotations." [
	spawnflags(flags) = [
		1 : "Rotation" : 0 : "Rotate train at rate specified by 'rotate'."
		2 : "Angles" : 0 : "Rotate to the angles specified by 'angles'."
		4 : "Stop" : 0 : "Stop train and wait to be retriggered."
		8 : "No Rotate" : 0 : "Stop train rotating when waiting to be triggered."
	   16 : "Damage" : 0 : "Cause damage based on 'dmg'."
	   32 : "Move Time" : 0 : "Interpret 'speed' as the length of time to take moving."
	   64 : "Set Damage" : 0 : "Set all targets damage to 'dmg'."
	]
	event(string)  : "target to trigger" : "Trigger target when train arrives at corner."
	noise(sound)  : "Custom stop sound"
	noise1(sound) : "Custom start sound"
	speed(integer) : "Set speed of train"
]
//_____ROTATE TRAIN_____
@PointClass base(AppearFlags, targetname, target) size(-8 -8 -8, 8 8 8) color(0 128 200) = func_rotate_train : "Rotating bmodel on path (controlled via path_rotate entities). This entity is moved along the path chain as the bmodel moves. Will start automatically if no targetname is defined" [
	spawnflags(flags) = [
		1 : "Start ON" : 0 : "Starts moving on spawn"
		64 : "Start OFF" : 0 : "tarts off and waits for trigger"
	]
	target(target_destination) : "Points to the rotate_object bmodel entity"
	targetname(target_source) : "Will wait for trigger if set."
	path(string) : "Location to start at after spawning"
	speed(integer) : "Initial travel speed (def=100)"
	dmg(integer) : "blocking damage (def=0)"
	sounds(choices) : "Sounds" = [
		0 : "Silent"
		1 : "Metal"
		5 : "Custom sounds"
	]
	noise(sound) : "Custom sound - stop"
	noise1(sound) : "Custom sound - moving (looping)"
	waitmin(integer) : "Time to wait before setup on spawn (def=0.1s)"
]
//_____MOVEWALL_____
@SolidClass base(HipBMODELSettings) = func_movewall : "Emulate collision for rotating BModel objects." [
	spawnflags(flags) = [
		1 : "Visible" : 0 : "Causes brush to be displayed"
		2 : "Touch" : 0 : "Cause damage when touched by player"
		4 : "No Solid" : 0 : "makes the brush non-solid"
	]
	dmg(integer) : "Damage (if Touched/Blocked)"
]
//_____ROTATE DOOR_____
@PointClass base(AppearFlags,targetname) size(-8 -8 -8, 8 8 8) color(0 128 200) = func_rotate_door : "The actual 'rotator' of toggleable BModel(brushwork) DOORS(rotate_object), moving around a point of rotation(info_rotate). SEE 'rotate_object' for more information." [
	spawnflags(flags) = [
		1 : "Stay Open" : 0 : "Reopen after closing, stops a once only door from closing if blocked"
		64 : "Start OFF" : 0 : "Starts off and waits for trigger"
	]
	target(target_destination) : "Points to the rotate_object bmodel entity"
	targetname(target_source) : "trigger entity (works with entity state system)"
	angles(integer) : "Degrees of Rotation(ex. 0 90 0)"
	target2(target_destination) : "Target2 (info_rotate)" :  : "(move on spawn)"
	dmg(integer) : "Damage caused when blocked (def=2) negative numbers =no damage"
	speed(integer) : "Time taken to rotate 1 cycle open/close"
	yaw_speed(integer)  : "Alternative time to slowdown object (def=speed)"
	waitmin(integer) : "Time to wait before setup on spawn (def=0.1s)"
	angles(integer) : "Rotation (XYZ) distance to travel in 1 cycle (open/close)"
	sounds(choices) : "Sounds" = [
		1 : "Medieval (def)"
		2 : "Metal"
		3 : "Base"
		4 : "Silent"
		//Patch2 additions
		5 : "Custom"
	]
	noise1(sound) : "Custom Sound (Open/Start)"
	noise2(sound) : "Custom Sound (Continuous moving)"
	noise3(sound) : "Custom Sound (Close/Finish)"	
]
//======================================================================
//
// BREAKABLES
//
//======================================================================

//_____BREAKABLE Common Settings
@baseclass base(AppearFlags,targetname,target,target2) = Break [
	health(integer) : "Health"
	style(choices) : "Style Default" = [
		1 : "Rock (default)"
		2 : "Wood"
		3 : "Glass"
		4 : "Metal"
		5 : "Brick"
		6 : "Ceramic"
		10: "Custom"
	]
	brksound(choices) : "Sound Breaking" = [
		0 : "Use Default"
		1 : "Rock"
		2 : "Wood"
		3 : "Glass"
		4 : "Metal"
		5 : "Brick"
		6 : "Ceramic"
		10: "Custom"
	]
	brkimpsound(choices) : "Sound Impact" = [
		0 : "Use Default"
		1 : "Rock"
		2 : "Wood"
		3 : "Glass"
		4 : "Metal"
		5 : "Brick"
		6 : "Ceramic"
		10: "Custom"
	]
	brkobjects(choices) : "Model Texture/Type" = [
		 0 : "Use Default"
		10 : "rock4_1 (dark bricks)"
		11 : "rock4_2 (light stone)"
		12 : "rock3_8 (light vertical)"
		13 : "city5_3 (plaster)"
		14 : "stone1_7b (blue stone)"
		15 : "cliff4 (Black rock)"
		20 : "dung01_3 (dark)"
		21 : "dung01_2 (light)"
		22 : "wizwood1_7 (mouldy)"
		30 : "window1_2 (blue sqr)"
		31 : "window01_4 (red)"
		32 : "window02_1 (yellow)"
		40 : "metal1_2 (gen brown)"
		41 : "metal4_5"
		42 : "metal7_7"
		50 : "wbrick1_5 (large brown)"
		51 : "city2_3 (small sewer)"
		52 : "city6_8 (small drywall)"
		53 : "wiz1_4 (large white)"
		54 : "city2_1 (small red)"
		60 : "ceramic_1"
	]
	noise(sound) : "Custom Sound - Initial Break"
	noise1(sound) : "Custom Sound - Impact 1"
	noise2(sound) : "Custom Sound - Impact 2"
	noise3(sound) : "Custom Sound - Impact 3"
	noise4(sound) : "Custom Sound - Impact 4"
	brkobj1(string) : "Custom Model - Rubble 1"
	brkobj2(string) : "Custom Model - Rubble 2"
	brkobj3(string) : "Custom Model - Rubble 3"
	brkobj4(string) : "Custom Model - Rubble 4"
	count(integer) : "Rubble Qty to spawn (def=4)"
	cnt(choices) : "Rubble (Random) to spawn" = [
		-1 : "No random qty"
		 0 : "Default = 4"
	]
	dmg(integer) : "Explosive Radius Damage"
	pos1(string) : "Particle colour" : : "x=start particle colour, y=random range, z=quantity"
	brkvelbase(string) : "Velocity Base (def=50 50 100)"
	brkveladd(string) : "Velocity Extra (def=100 100 150)"
	brkavel(integer) : "Velocity Rotation (def=200)"
	brkfade(integer) : "Rubble fade timer (def=4+random()x4)"
	brkmondmg(integer) : "Damage multiplier for monster damage"
	angles(vector) : "Direction to throw rubble(override default(impact direction)"
	brkgravity(integer) : "Rubble gravity (def=1), useful for under water"
	brktrigjump(choices) : "Monster jump only damage" = [
		 0 : "Default"
		 1 : "Yes"
	]
	brktrigmissile(choices) : "Explosive damage only" = [
		0 : "Default"
	    1 : "Yes"
	]
	brktrignoplayer(choices) : "Player damage" = [
		 0 : "Default"
	     1 : "No Player Damage"
	]
	brkdelaydamage(integer) : "Delay - pause before enabling damage on this breakable."
 ]

//_____BREAKABLE____
@SolidClass base(Break,FuncLighting) = func_breakable : "Breakable - A BModel(brushwork) object the can break into pieces when damaged, or triggered(?). " [
    spawnflags(flags) = [
		1 : "Start OFF (hidden)" : 0 : "Start hidden"
		2 : "No Damage" : 0 : "Cannot be damaged"
		4 : "Explosion" : 0 : "Produces explosion"
		8 : "Silent" : 0 : "No Breaking Sounds"
		16 : "Rubble Damage" : 0 : "Rubble does damage"
		32: "No Monsters" : 0 : "Immune to monster damage"
		64: "No Sounds" : 0 : "No Impact Sounds"
		128: "No Rubble Rotate" : 0 : "No Y rotation for rubble"
	]
]
//_____BREAKABLE_SPAWNER_____
@PointClass base(Break) color(128 128 200) = func_breakable_spawner : "Breakable Spawner - Spawn breakable object 'pieces' from a single 'point' entity." [
    spawnflags(flags) = [
		4 : "Explosion" : 0 : "Produces explosion"
		8 : "Silent" : 0 : "No Breaking Sounds"
		16 : "Rubble Damage" : 0 : "Rubble does damage"
		32: "No Monsters" : 0 : "Immune to monster damage"
		64: "No Sounds" : 0 : "No Impact Sounds"
		128: "No Rubble Rotate" : 0 : "No Y rotation for rubble"
	]
]
//_____BreakWallSettings_____
@baseclass = BreakWallSettings [
	wait(choices) : "Trigger Quantity" = [
		0 : "Multiple Times(def)"
	   -1 : "Once Only"
	]
	waitmin(integer) : "Randomized Fadeout timer"
]	
//_____BREAKABLE WALL_____
@SolidClass base(AppearFlags,targetname,BreakWallSettings,FuncLighting) = func_breakable_wall : "Breakable Wall - Switchable bmodel for breakable setups with optional collision." [
	spawnflags(flags) = [
		1 : "Start ON" : 0 : "Start visual to player"
		2 : "Solid"    : 0 : "Has player collision"
		4 : "Fadeout"  : 0 : "Fadeaway once triggered"
	]	
]
//_____func_pushable Settings_____
@baseclass = FuncPushableSettings [
    message(string)      : "Message (while moving)"
    speed(integer)       : "Speed (pushing (def = 1)"
    waitmin2(integer)    : "Alpha (pushing (0.0 ->1)"
    health(integer)      : "Health"
    death_dmg(choices)   : "Explosions (reqs health)" = [
        0 : "Default(OFF)"
        1 : "Enabled"
    ]
    target2(target_destination) : "Target (breakable_spawner ONLY)"
    bleedcolour(string) : "Impact particle color (ex 100)"
    
//------Sound Options ------
    
    style(choices) : "Sound+Particle Style" = [
		0 : "Use Default"
		1 : "Rock (brown impacts)"
		2 : "Wood (light brown impacts)"
		3 : "Glass (light yellow impacts)" 
		4 : "Metal (green/brown impacts)"
		5 : "Brick (brown impacts)"
	   10 : "Custom (white/grey impacts)"
	]
    noise1(sound)        : "Custom Move Sound(1)"
    noise2(sound)        : "Custom Move Sound(2)"
    noise3(sound)        : "Custom Move Sound(3)"
    waitmin(integer)     : "Sound Duration (def=0.5s)"
]
//_____PUSHABLE_____
@SolidClass base(AppearFlags,targetname,FuncPushableSettings,FuncLighting) = func_pushable : "Pushable/moveable BModel(brushwork)" [
    spawnflags(flags) = [
		2 : "Damageable" : 0 : "Pushable can be damaged or destroyed."
		8 : "No Floor Check"    : 0 : "No floor below check for extra velocity."
	  16 : "Floating"  : 0 : "Pushable starts off floating (until touched)."
	  32 : "No Monsters" : 0 : "Cannot be damaged by monsters."
	  64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
]
//_____trig MONSTER BREAK_____
@PointClass base(AppearFlags,targetname) color(200 128 200) size(-8 -8 -8, 8 8 8) = trigger_monsterbreak : "Trigger monster + breakable" [
	spawnflags(flags) = [
		1 : "No Delay" : 0 : "Instantly trigger"
		2 : "Wake Animation" : 0 : "Use Special monster animation"
	]
	target(string) : "targets func_breakable"
	target2(string) : "targets Monster"
	wait(integer) : "Time Delay before firing breakable (def=0.2s)"
]
//_____trig EXPLODE_____
@PointClass base(AppearFlags,targetname) color(200 128 128) size (-4 -4 -4, 4 4 4) = trigger_explode : "Trigger Sprite Explosion - Triggered entity producing damage + sprite explosion" [
	spawnflags(flags) = [
		2 : "NoParticles" : 0 : "No old particle effect"
		4 : "DUST" : 0 : "Dust particle explosion (use angle for direction)"
	]
	dmg(integer) : "Explosive radius (def=40, -1=no damage)"
	delay(integer) : "Delay before explosion"
	noise(sound) : "Explosive Wav file to play"
	wait(integer) : "Re-trigger (def=-1 trig once)"
	style(choices) : "Explosion Type" = [
		0 : "Explosive"
		1 : "Plasma"
		2 : "Poison"
		3 : "Electric"
		4 : "Burst (Smoke/Flame/Poison)"
	]
	height(choices) : "Explosion Size" = [
		1 : "Small (Default)"
		2 : "Medium"
		3 : "Large"
	   -1 : "Random"
	]
]
//_____Breakable Pots and Vases_____
@baseclass = BreakableVases [
	spawnflags(flags) = [
		1 : "Start Off" : 0 : "Will wait for trigger to spawn"
		2 : "No Damage" : 0 : "Cannot be damaged or shot, trigger only"
		4 : "Explosion" : 0 : "trigger sprite/particle explosion"
		8 : "Silent" : 0 : "No initial breakage sound"
		16 : "Damage" : 0 : "Spawning rubble can damage (def = 2, use dmg key for touch damage)"
		32 : "No Monster" : 0 : "monsters cannot damage this breakable and/or spawning rubble will not damage monsters"
		64 : "No Sound" : 0 : "Spawning rubble has no impact sounds"
		128 : "No Rotate" : 0 : "Spawning rubble has No Y rotation"
		
	]
	mdl(string) : "Change default model"
	brkobj1(string) : "Breakable rubble 1 replacement model"
	brkobj2(string) : "Breakable rubble 2 replacement model"
	brkobj3(string) : "Breakable rubble 3 replacement model"
	brkobj4(string) : "Breakable rubble 4 replacement model"
	exactskin(integer) : "Skin override of model (def 0, cannot be negative)"
	angle(integer) : "Yaw rotation of model (-1/0 = random rotation)"
	health(integer) : "amount of damage to take before breaking (def 1)"
	count(integer) : "minimum quantity to spawn (def 4)"
	cnt(integer) : "random quantity to spawn (def 4) final qty = count + random(cnt)"
	dmg(integer) : "explosive radius damage (emits from center of func object)"
	pos1(string) : "x=start particle colour, y=random range, z=quantity (def '168 8 1')"
	bbmins(vector) : "Model bounding box MINIMUM size (def '-8 -8 -16')"
	bbmaxs(vector) : "Model bounding box MAXIMUM size (def '8 8 16')"
	brkvol(vector) : "Volume size for spawning pieces inside of (def '16 16 32')"
	brkmdltype(string) : "Predefined sizes (0/1 = '16 16 32' and 2/3 = '24 24 40')"
	brkpuff(integer) : "Spawn explosive puff of smoke and extra particles (-1 = disable)"
	brkvelbase(vector) : "Base amount for velocity of broken parts (def '50 50 100')"
	brkveladd(vector) : "Random additions for velocity of broken parts (def '100 100 150')"
	brkavel(integer) : "Amount of breaking object angle velocity (def 200)"
	brkfade(integer) : "Fade time before rubble fades away (def 4+random()x4)"
	brkgravity(integer) : "will change the gravity for rubble, useful for underwater"
	]

@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot1a.mdl", "skin": exactskin},
	"progs/brk_pot1a.mdl"}}) = misc_breakable_pot1a : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot2a.mdl", "skin": exactskin},
	"progs/brk_pot2a.mdl"}}) = misc_breakable_pot2a : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot1c.mdl", "skin": exactskin},
	"progs/brk_pot1c.mdl"}}) = misc_breakable_pot1c : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot2c.mdl", "skin": exactskin},
	"progs/brk_pot2c.mdl"}}) = misc_breakable_pot2c : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-10 -10 -16, 10 10 16) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot1b.mdl", "skin": exactskin},
	"progs/brk_pot1b.mdl"}}) = misc_breakable_pot1b : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-10 -10 -16, 10 10 16) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot2b.mdl", "skin": exactskin},
	"progs/brk_pot2b.mdl"}}) = misc_breakable_pot2b : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-12 -12 -16, 12 12 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot1d.mdl", "skin": exactskin},
	"progs/brk_pot1d.mdl"}}) = misc_breakable_pot1d : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-12 -12 -16, 12 12 32) color(128 128 192) model({{
		exactskin >= 1 -> 	{"path": "progs/brk_pot2d.mdl", "skin": exactskin},
	"progs/brk_pot2d.mdl"}}) = misc_breakable_pot2d : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot1aflr.mdl", "skin": exactskin},
	"progs/brk_pot1aflr.mdl"}}) = misc_breakable_pot1aflr : "Breakable ceramic pot (model)" []
@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_pot2aflr.mdl", "skin": exactskin},
	"progs/brk_pot2aflr.mdl"}}) = misc_breakable_pot2aflr : "Breakable ceramic pot (model)" []

@PointClass base(AppearFlags,targetname,target,BreakableVases)  size(-16 -16 -16, 16 16 32) color(128 128 192) model({{
	exactskin >= 1 -> 	{"path": "progs/brk_vase1.mdl", "skin": exactskin},
	"progs/brk_vase1.mdl"}}) = misc_breakable_vase : "Breakable ceramic vase (model)" []
	
//======================================================================
//
// MONSTERS
//
//======================================================================

//_____Monster Common Settings_____
@baseclass base(AppearFlags) color(220 0 0) offset(0 0 24) = Monster [
spawnflags(flags) = [
		1 : "Ambush" : 0 : "Wakeup when player is seen"
		8 : "No Sight" : 0 : "No sight sound"
	  16 : "No Idle" : 0 : "No idle sounds (cupboard monster)"
	  32 : "NoGFX" : 0 : "No spawn effect or sound when triggered."
	  64 : "Start OFF" : 0 : "Starts OFF, trigger to Spawn"
	128 : "Angry" : 0 : "Will spawn angry at the player"
	]
//----- monster common-----
	targetname(target_source) : "Name" : : "Name of monster used for triggering/targetting"
	target(target_destination) : "Target (path_corner etc)" : : "A path_corner to walk towards or a trigger event on death"
	target2(target_destination) : "Target2 (on death)" : : "Additional trigger events to fire on death of monster (needs target to be defined)"
	health(integer) : "Health (define custom HP's)" :  : "Override health defined in QC"

	angrytarget(target_destination) : "Angry target (on spawn)" : : "Something (monster/player) to get angry at once spawned"
	deathtarget(target_destination) : "Death target (on death)" : : "Entity to trigger upon death (useful if target field already in use)"
	
//----- Infighting/Turret-----
	
	noinfighting(choices) : "Infighting" : : "Set to 1, will not react to any infighting" = [
		0 : "Yes, infighting(def)"
		1 : "NO infighting"
	]
	pain_ignore(choices) : "Infighting Damage" = [
		0 : "Yes(def)"
		1 : "No"
	]
	infightextra(choices) : "Damage Multiplier" : : "Damage multiplier for infighting" = [
		1 : "normal damage" 
		2 : "double damage" 
		4 : "quad damage"
	]
	movespeed(choices) : "Monster Movement(turret)" : : "-1 = no movement(turret), =0/1 free movement (default)" = [
		0 : "Default"
	   -1 : "Stationary(turret)"
		1 : "Free roam"
	]	//turrethealth  : % HP for a trigger event to happen (+releases turret monsters)	//turrettarget  : Targets to fire when % HP turrethealth is reached	//turrethealth2 : % HP for a trigger event to happen (must be < turrethealth)	//turrettarget2 : Targets to fire when % HP turrethealth2 is reached	
	turrethealth(integer) : "Health % (for release (0.0->1.0)" : : "Percentage of monster health remaing to release the monster(turret) from being stationary." 
	turrettarget(target_destination) : "Target (on release)" : : "Target(s) to fire when monsters(turret) % HP's triggers release"
	
//----- MISC Settings -----
	
	no_zaware(choices) : "Z-Aware" : : "Set to 1, all Z Aware projectiles will be disabled" = [
		0 : "Yes, z-aware(def)"
		1 : "NO z-aware"	
	]
	no_liquiddmg(choices) : "Liquid Damage" : : "Set to 1, blocks all liquid (slime/lava) damage checks" = [
		0 : "Yes, liquid damage(def)"
		1 : "NO liquid damage"
	]
	gibondeath(choices) : "Gib On Death" = [
		0 : "Default"
		1 : "Shower of gibs"
	]
	bodyfadeaway(integer) : "Body/gibs FADE Time" : : "Time (secs) before body/head will fade away, formula is( TIME + 10 + 0-1 + <bodytimer>)"
	exactskin(integer) : "Exact Skin (not set=random)" :  : "Override default skin 0 (no range check), or leave blank for random."
	nomonstercount(choices) : "Monster Count" : : "Set to 1, excludes from the maps 'initial' monster count" = [
		 0 : "Yes, count (def)"
		 1 : "NO, do not count"
	]
	bboxtype(choices) : "Bounding box size" : : "An advanced setup for advanced mappers ;)" = [
		1 : "Tiny"
		4 : "Short"
		5 : "Tall" 
		7 : "Wide"
		8 : "Giant"
	   10 : "Massive"
	]
	ignore_monjump(integer) : "Set to 1 to make this monster ignore monster jump triggers."
]
@baseclass base(Monster) size(-16 -16 -24, 16 16 16) = MonTiny []
@baseclass base(Monster) size(-32 -32 -24, 32 32 40) = MonDog []
@baseclass base(Monster) size(-32 -32 -24, 32 32 64) = MonDemon []
@baseclass base(Monster) size(-16 -16 -24, 16 16 24) = MonFish []
@baseclass base(Monster) size(-32 -32 -24, 32 32 64) = MonGolem []
@baseclass base(Monster) size(-16 -16 -24, 16 16 32) = MonShort []
@baseclass base(Monster) size(-16 -16 -24, 16 16 40) = MonTall []
@baseclass base(Monster) size(-32 -32 -24, 32 32 64) = MonWide []
@baseclass base(Monster) size(-32 -32 -24, 32 32 64) = MonGiant []
@baseclass base(Monster) size(-32 -32 -24, 32 32 64) = MonMassive []
@baseclass base(Monster) = JumpingMon [
	jumpdist(vector) : "Jump distance - x 0 y - x being jump distance and y jump height"
	jumprange(vector) : "Range at which the monster will attempt a jump attack - x y 0, for example 200 300 0, which means the monster will attempt jumps when the player is between 200 and 300 units from it"
	]
//_____Qouth Additions (*mdl files required for use)_____
//@PointClass base(MonTall) model"progs/mon_dguardq.mdl") = monster_death_guard : "Death Guard(Quoth)" []
//@PointClass base(MonTall) model"progs/mon_dlord.mdl") = monster_death_lord : "Death Lord(Quoth)" []
//@PointClass base(MonFish) model"progs/mon_sentinel.mdl") = monster_sentinel : "Floating Sentry(Quoth)" []
//_____Qouth Additions (*mdl files required for use)_____
@PointClass base(MonShort) model({{
	exactskin >= 1 -> 	{"path": "progs/mon_soldier.mdl", "skin": exactskin},
								 "progs/mon_soldier.mdl"
}}) = monster_army : "Grunt, 30 health points." []
@PointClass base(MonShort) model({"path": "progs/mon_soldier.mdl", "skin": 4 }) = monster_army_rocket  : "Rocket Soldier, 45 health points." []
@PointClass base(MonShort) model({"path":"progs/mon_soldier.mdl", "skin": 6 }) = monster_army_grenade : "Grenade Soldier, 60 health points." []
@PointClass base(MonShort) model({"path":"progs/mon_soldier.mdl", "skin": 8 }) = monster_army_plasma : "Plasma Soldier, 75 health points." []
@PointClass base(MonDog, JumpingMon) model("progs/mon_dog.mdl") = monster_dog : "Nasty Doggie (Rottweiler), 25 health points." []
@PointClass base(MonFish) model("progs/mon_eel.mdl") = monster_eel : "Electrifying Eel, 35 health points." [
    spawnflags(flags) = [ 4 : "Liquid Block" : 0 : "Liquid surfaces block wakeup/sight lines." ]
]
@PointClass base(MonFish) model({{
	spawnflags & 2 -> 	{"path": "progs/mon_fish.mdl", "frame": 105},
								"progs/mon_fish.mdl"
}}) = monster_fish : "Rotfish, 25 health points." [
	spawnflags(flags) = [ 
	    2 : "Small" : 0 : "Smaller version, less HP." 
	    4 : "Liquid Block" : 0 : "Liquid surfaces block wakeup/sight lines." 
	]	
]
@PointClass base(MonTiny) model("progs/mon_lostsoul.mdl") = monster_lostsoul : "Lost Soul, 30 health points." []
@PointClass base(MonTiny, JumpingMon) model({{
	exactskin >= 1 -> 	{"path": "progs/mon_scorpion.mdl", "skin": exactskin},
	spawnflags & 4 -> 	{"path": "progs/mon_scorpion.mdl", "skin": 3},
								 "progs/mon_scorpion.mdl"
}}) = monster_scorpion : "Scorpion, 80/120 health points." [ 
    spawnflags(flags) = [ 4 : "Stinger" : 0 : "Works like the Black crab from HL2 with a poison debuff." ] 
]
@PointClass base(MonTiny, JumpingMon) model({{
	((spawnflags & 2) != 0 && (spawnflags & 4) != 0) -> {"path": "progs/mon_spiderg.mdl", "frame": 013 }, 
	spawnflags & 2 -> 	{"path": "progs/mon_spiderg.mdl"},
	spawnflags & 4 -> 	{"path": "progs/mon_spiderb.mdl", "frame": 013},
								 "progs/mon_spiderb.mdl"
}}) = monster_spider : "Spider, 30/75 health points." [
	spawnflags(flags) = [ 
		2 : "Large Green" : 0 : "Large green spitting variety."
		4 : "On Ceiling" : 0 : "Start on ceiling above, waiting... "
	]			
]
@PointClass base(MonTiny, JumpingMon) model({"path": "progs/mon_steelclaw.mdl", "skin": 0}) = monster_steelclaw : "Steelclaw, 75 health points." []
@PointClass base(MonTiny, JumpingMon) model({{
	((spawnflags & 2) != 0 && (spawnflags & 4) != 0) -> {"path": "progs/mon_vorelingp.mdl", "skin": 0, "frame": 013},
    spawnflags & 4 -> {"path": "progs/mon_voreling.mdl", "skin": 0, "frame": 013}, 
	spawnflags & 2 -> {"path": "progs/mon_vorelingp.mdl", "skin": 0},
							    "progs/mon_voreling.mdl"
}}) = monster_voreling : "Voreling, 30/60 health points." [
	spawnflags(flags) = [
		2 : "Large Purple" : 0 : "Large purple spitting variety."
		4 : "On Ceiling" : 0 : "Start on ceiling above, waiting... "
	]	
]
@PointClass base(MonTiny, JumpingMon) model({{
	((spawnflags & 2) != 0 && (spawnflags & 4) != 0) -> {"path": "progs/mon_swamplingp.mdl", "skin": 0, "frame": 013},
    spawnflags & 4 -> {"path": "progs/mon_swampling.mdl", "skin": 0, "frame": 013},
    spawnflags & 2 -> {"path": "progs/mon_swamplingp.mdl", "skin": 0},
								"progs/mon_swampling.mdl"
}}) = monster_swampling : "Swampling, 30/60 health points." [
    spawnflags(flags) = [
		2 : "Large Green" : 0 : "Large dark green spitting variety."
		4 : "On Ceiling" : 0 : "Start on ceiling above, waiting... "
	]
]
//_____ZOMBIES_____
@PointClass base(MonShort) model({{
	spawnflags & 4 ->		{"path": "progs/mon_zombie.mdl", "frame": 173, "skin": exactskin},
	spawnflags & 1 ->		{"path": "progs/mon_zombie.mdl", "frame": 192, "skin": exactskin},
	exactskin >= 1 ->		{"path": "progs/mon_zombie.mdl", "skin": exactskin},
									"progs/mon_zombie.mdl"
}}) = monster_zombie : "Zombie, 60 health points." [ 
    spawnflags(flags) = [ 
		1 : "Crucified"  : 0 : "If crucified, stick the bounding box 12 pixels back into a wall to look right."
		2 : "Ambush"   : 0 : "Only wake upon seeing the player, not by other monsters."
		4 : "On Floor"  : 0 : "Spawn the zombie on the floor (angles = position)."
	]  
]
@PointClass base(MonShort, JumpingMon) model({{
	//on floor, face down, green
	((spawnflags & 4) != 0 && (aflag) == 1) && (poisonous) == 1 -> {"path": "progs/mon_zombiek.mdl", "skin": 1, "frame": 109},
	//on floor, face down
	((spawnflags & 4) != 0 && (aflag) == 1) -> {"path": "progs/mon_zombiek.mdl", "frame": 109},
	//on floor, face up, green
	((spawnflags & 4) != 0 && (aflag) == 2) && (poisonous) == 1 -> {"path": "progs/mon_zombiek.mdl", "skin": 1, "frame": 131},
	//on floor, face up
	((spawnflags & 4) != 0 && (aflag) == 2) -> {"path": "progs/mon_zombiek.mdl", "frame": 131},
	//standing, posionous
	poisonous == 1 -> {"path": "progs/mon_zombiek.mdl", "skin": 1},
								 //standing, posionous
								 "progs/mon_zombiek.mdl"
}}) = monster_zombiek : "Zombie Knight, 60 health points." [ 
    spawnflags(flags) = [ 4 : "On Floor" : 0 : "Spawn the zombie on the floor (angles = position)." ] 
	poisonous(choices) : "Poison attack+skin"  :  : "Change skin + poison dmg" = [
        0 : "Default"
        1 : "Poison Zombie"
    ] 
    aflag(choices) : "Starting position on floor" = [
		0 : "Random"
		1 : "Facing down"
		2 : "Facing up"
	]
]
@PointClass base(MonShort) model({{ 
	spawnflags == 4 ->	{"path": "progs/mon_zombie.mdl", "skin": 4, "frame": 112},
	exactskin >= 1 ->	{"path": "progs/mon_zombie.mdl", "skin": exactskin},
								 "progs/mon_zombie.mdl"
}})= monster_mummy : "Poison Zombie, 60 health points." [             
    spawnflags(flags) = [ 4 : "On Floor" : 0 : "Spawn the zombie on the floor (angles = position)." ] 
]
@PointClass base(MonShort) model({{
//((spawnflags & 2) != 0 && (spawnflags & 4) != 0) ->
	//hobbled, poisonous
	((spawnflags & 4) != 0 && (poisonous) == 1) -> {"path":"progs/mon_boil.mdl", "skin": 1, "frame": 059},
	//hobbled
	spawnflags & 4 -> {"path":"progs/mon_boil.mdl", "frame": 059},
	//standing, poisonous 
	poisonous == 1 ->  {"path":"progs/mon_boil.mdl", "skin": 1},
								 //standing
								 "progs/mon_boil.mdl"
}}) = monster_boil : "Exploding Boil, 75 health points." [
	spawnflags(flags) = [ 
		2 : "Hanging" : 0 : "Hanging on wall upside down by spikes, cannot be displayed in editor"
		4 : "Hobbled" : 0 : "Hobbled on the floor, random A/B position"
	]
	death_dmg(integer) : "Damage on Death def=100" :  : "Damage on Death"
	t_width(integer) : "Explosive radius damage (on death (def=60)"
	wait(integer) : "Blood squirt timer" : : "Time between random squirts of blood (def = wait + rnd x wait)"
	poisonous(choices) : "Poisonous gib/explosion+skin"  :  : "Green blood, gibs and poison debuff attack with radius damage." = [
        0 : "Default"
        1 : "Poison Boil"
	]	
]
@PointClass base(MonTall) model({"path": "progs/mon_enforcer.mdl", "skin": 0}) = monster_enforcer : "Enforcer, 80 health points." []
@PointClass base(MonTall) model({"path": "progs/mon_enforcer.mdl", "skin": 4}) = monster_defender : "Defender, 100 health points." []
@PointClass base(MonTall) model("progs/mon_pyro.mdl") = monster_pyro : "Pyro, 100 health points." []
@PointClass base(MonTall) model("progs/mon_fumigator.mdl") = monster_fumigator : "Fumigator, 100 health points." []
@PointClass base(MonShort) model("progs/mon_jim.mdl") = monster_jim : "Fast moving flying robot, 50/100 health points."
[ spawnflags(flags) = [ 4 : "Rockets (has less HP)" : 0 ] ]
@PointClass base(MonTall) model({"path": "progs/mon_enforcer.mdl", "skin": 6}) = monster_eliminator : "Eliminator, 120 health points." [
	attack_sniper(choices) : "Unlimited ATTACK Range" = [
		0 : "No, Defualt"
		1 : "Yes, Unlimited"
    ]
]
@PointClass base(MonTall) model("progs/mon_centurion.mdl") = monster_centurion : "Centurion, 120 health points." []
@PointClass base(MonDemon) model({{
	poisonous == 1 -> 	{"path": "progs/mon_demon.mdl", "skin": 1},
	exactskin >= 1 -> 		{"path": "progs/mon_demon.mdl", "skin": exactskin},
									 "progs/mon_demon.mdl"
}}) = monster_demon1 : "Fiend (Demon), 300 health points." [
	poisonous(choices) : "Poison attack+skin" : : "Change skin and do poison damage" = [
	    0 : "Default"
        1 : "Poisonous"
    ] 
]
//_____GOLEM_____
@PointClass base(MonGolem) model({{
	((spawnflags & 2) != 0 && (frame) == "") -> {"path":"progs/mon_golem.mdl", "skin": 1, "frame": 0 },
	((spawnflags & 2) != 0 && (frame) != "") ->  {"path":"progs/mon_golem.mdl", "skin": 1,"frame": frame},
																		   "progs/mon_golem.mdl"	
}}) = monster_golem : "Golem, 500 health points." [
	spawnflags(flags) = [ 
		2 : "Stone Statue" : 0 : "Stone statue until triggered."
		4 : "Melee+Stomp Only" : 0 : "Melee and Stomp only attacks, no rockstorm rage."
	]
//-----Statue Setup-----	
	frame(integer) : "Statue Pose (def=0)" :  : "Override statue pose (def=0, 0->250)"
]
//_____KNIGHTS_____
@PointClass base(MonShort) model({{
	((spawnflags & 2) != 0 && (frame) == "") -> {"path":"progs/mon_knight.mdl", "skin": 4, "frame": 44 },
	((spawnflags & 2) != 0 && (frame) != "") ->	 {"path":"progs/mon_knight.mdl", "skin": 4,"frame": frame},
	exactskin >= 1 -> {"path": "progs/mon_knight.mdl", "skin": exactskin},
																	  "progs/mon_knight.mdl"	
}}) = monster_knight : "Knight, 75 health points." [
	spawnflags(flags) = [ 
		2 : "Stone Statue" : 0 : "Stone statue until triggered."
		4 : "Not Frozen" : 0 : "Will start active (works with statue spawnflag)."
	]
	startingpose(integer) : "Starting pose, 5=start kneeling down, 6=start upright to attention"
//-----Statue Setup-----
	frame(integer) : "Statue Pose (def=44)" :  : "Override statue pose (def=44, 1->163)"
]
@PointClass base(MonTall) model({{
	((spawnflags & 2) != 0 && (frame) == "") -> {"path":"progs/mon_hknight.mdl", "skin": 1, "frame": 133 },
	((spawnflags & 2) != 0 && (frame) != "") ->	 {"path":"progs/mon_hknight.mdl", "skin": 1,"frame": frame},
																	  "progs/mon_hknight.mdl"	
}}) = monster_hell_knight : "Hell Knight, 250 health points." [
	spawnflags(flags) = [ 
		2 : "Stone Statue" : 0 : "Stone statue until triggered."
		4 : "Not Frozen" : 0 : "Will start active (works with statue spawnflag)."
	]	
//-----Statue Setup-----	
	frame(integer) : "Statue Pose (def=133)" :  : "Override statue pose (def=133, 1->165)."
]
@PointClass base(MonTall) model({{
	spawnflags & 2 -> 	{"path":"progs/mon_hknight.mdl", "skin": 1, "frame": 98},
								{"path":"progs/mon_hknight.mdl", "frame": 98}
}})  = monster_hell_pointknight : "Special Electricity Pointing Hell Knight." [
	spawnflags(flags) = [ 
		2 : "Stone Skin" : 0 : "Stone statue skin."
	]
	target(target_destination) : "target (for electricity, *required)" :  : "Target for electricity. NOTE: MUST set, to spawn in map!"
	target2(target_destination) : "target2 (electricity stops)" : : "Trigger to fire when electricity stopped"
	t_length(integer) : "target random wobble" : : "0 = default 5"
	dmg(integer) : "target contact damage" : : "0 = default 5"
	pos1(string) : "(x y z) lightning offset" : : "uses v_forward/v_right/v_up"
	pos2(string) : "(x y z) lightning random" : : "uses v_forward/v_right/v_up"
	pos3(string) : "Animation frame set" : : "Start/Finish/Direction"
]
//_____ D version baddies____
@PointClass base(MonShort) model({{
	poisonous == "1" -> {"path": "progs/mon_dcrossbow.mdl", "skin": 1},
	exactskin >= 1 -> {"path": "progs/mon_dcrossbow.mdl", "skin": exactskin},
								   "progs/mon_dcrossbow.mdl"
}}) = monster_dcrossbow : "Crossbow Knight, 75 health points." [ 
    spawnflags(flags) = [
        2 : "Sniper" : 0 : "No max range limitations (sniper mode)."
        4 : "Tracking" : 0 : "Enable tracking for the firing of bolts (really hard)."
    ]
    poisonous(choices) : "Poison attack+skin"  :  : "Change skin + poison dmg" = [
        0 : "Default"
        1 : "Poisonous"
    ] 
]
@PointClass base(MonShort) model({{
		exactskin >= 1 -> {"path": "progs/mon_dguard.mdl", "skin": exactskin},
	"progs/mon_dguard.mdl"}}) = monster_dguard : "Death Guard (Quoth), 125 health points." []
@PointClass base(MonTall, JumpingMon) model("progs/mon_dfury.mdl") = monster_dfury : "Fury Knight, 400 health points." []
@PointClass base(MonTall) model({{
		exactskin >= 1 -> {"path": "progs/mon_dknight.mdl", "skin": exactskin},
	"progs/mon_dknight.mdl"}}) = monster_dknight : "Death Knight, 250 health points." []
@PointClass base(MonTall) model({{
	exactskin >= 1 -> 	{"path": "progs/mon_dsergeant.mdl", "skin": exactskin},
	"progs/mon_dsergeant.mdl"}}) = monster_dsergeant : "Death Sergeant, 400 health points." []

//_____OGRES_____
@PointClass base(MonWide) model({{
	spawnflags & 2 -> 	{"path": "progs/mon_ogre.mdl", "skin": 1},
	spawnflags & 4 -> 	{"path": "progs/mon_ogre.mdl", "skin": 1},
						"progs/mon_ogre.mdl"
}}) = monster_ogre : "Ogre, 200 health points." [ 
    spawnflags(flags) = [ 
        2 : "Nail" : 0 : "Fires 4 nails in a random pattern."
        4 : "Green" : 0  : "Green leather armour and increased HP."
	] 	
]
//_____Fishing OGRE needs some spawnflags and keys removed_____
@PointClass base(MonWide) model({{
	spawnflags & 4 -> 	{"path": "progs/mon_ogrefish.mdl", "skin": 1},
								 "progs/mon_ogrefish.mdl"
}}) = monster_ogre_fishing : "A Fishing Ogre, who knew! 150/350 health points." [
	spawnflags(flags) = [ 4 : "Green Skin" : 0 : "Green leather armour and increased HP." ] 
]
//_____Ghost Ogre has Limited Settings_____
@PointClass base(AppearFlags,targetname) model("progs/mon_ogrefish.mdl") = monster_ogre_fishing_ghost : "Ghost Fishing Ogre, No health points and cannot be woken up." [
    spawnflags(flags) = [
		32 : "NoGFX"  : 0 : "No spawn effect or sound when triggered."
		64 : "Start OFF" : 0 : "Starts OFF, trigger to spawn."
	] 		
]     
@PointClass base(MonWide) model({{
	spawnflags & 4 -> 	{"path": "progs/mon_hogre.mdl", "skin": 1},
								 "progs/mon_hogre.mdl"
}}) = monster_hogre : "Hunter Ogre, 200 health points." [
	spawnflags(flags) = [ 4 : "Metal Skin" : 0 : "Chain mail metal armour and +HP" ]
 ]
@PointClass base(MonWide) model({{
	spawnflags & 4 -> 	{"path": "progs/mon_hogremac.mdl", "skin": 1},
									 "progs/mon_hogremac.mdl"
}}) = monster_hogremac : "Hunter Ogre Mace, 200 health points." [ 
	spawnflags(flags) = [ 4 : "Metal Skin" : 0 : " Chain mail metal armour and +HP" ]
 ]
@PointClass base(MonWide) model({{
	spawnflags & 4 -> 	{"path": "progs/mon_hogreham.mdl", "skin": 1},
									 "progs/mon_hogreham.mdl"
}}) = monster_hogreham : "Hunter Ogre Hammer, 300 health points." [ 
	spawnflags(flags) = [ 4 : "Metal Skin" : 0 : "Chain mail metal armour and +HP" ]
 ]
//----------------------------------------------------------------------
@PointClass base(MonGiant) model("progs/mon_drole.mdl") = monster_drole : "Drole, 500 health points." []
@PointClass base(MonGiant, JumpingMon) model("progs/mon_minotaur.mdl") = monster_minotaur : "Minotaur, 500 health points." [
	spawnflags(flags) = [ 4 : "Minions" : 0  ] 
	poisonous(integer) : "Set to -1 for the minion version to not be poisonous"
]
@PointClass base(MonWide) model({{
spawnflags & 4 -> 	{"path": "progs/mon_shalrath.mdl", "skin": 2},
exactskin >= 1 -> 	{"path": "progs/mon_shalrath.mdl", "skin": exactskin},
							 "progs/mon_shalrath.mdl"
}}) = monster_shalrath : "Vore (Shalrath), 400 health points."
[ spawnflags(flags) = [ 4 : "Minions" : 0 : "Spawn minions (vorelings) to attack the player" ] ]
@PointClass base(MonGiant) model("progs/mon_freddie.mdl") = monster_freddie : "Freddie, 500 health points." [
	spawnflags(flags) = [
		2 : "Laser" : 0
	]
]
//_____SEEKER_____
@PointClass base(MonGiant) model
({{
	state == "1" -> 	{"path": "progs/mon_seeker.mdl", "frame": 209},
	state == "2" -> 	{"path": "progs/mon_seeker.mdl", "frame": 228},
								 "progs/mon_seeker.mdl"
}}) = monster_seeker : "Seeker, 500 health points." [
	spawnflags(flags) = [
		4 : "Shield" : 0 : "Start with shield ON and waits for trigger"
	]
	state(choices) : "Arm setup" = [
		0 : "Both Arms (def)"
		1 : "Right Arm ONLY"
		2 : "Left Arm ONLY"
	]
	target2(target_destination) : "target2" : : "triggered when shield turned off"
]
//_____SHAMBLER_____
@baseclass = shambler_unique [
//----- shambler unique-----
	poisonous(choices) : "Poison attack+skin" :  : "Green skin + Poison debuff attack on melee claws" = [
		0 : "Default"
		1 : "POISON"
	]
	attack_sniper(choices) : "Unlimited ATTACK Range": : "Lightning attack has no range limit (previous 600 units)" = [
		0 : "No, Default"
		1 : "Yes, Unlimited"
	]
]
@PointClass base(shambler_unique,MonMassive) model({{
	poisonous == "1" -> {"path": "progs/mon_shambler.mdl", "skin": 1},
								   "progs/mon_shambler.mdl"
}}) = monster_shambler : "Shambler - 600 health points. Player rockets only do 50% damage" []
//_____TARBABY_____
@PointClass base(MonTall) model({{
	exactskin >= 1 -> 	{"path":"progs/mon_tarbaby.mdl", "skin": exactskin},
	poisonous == 1 -> 	{"path":"progs/mon_tarbaby.mdl", "skin": 3},
						"progs/mon_tarbaby.mdl"
}}) = monster_tarbaby : "Spawn (Tarbaby), 80 health points." [
	spawnflags(flags) = [ 4 : "Jump Less" : 0 : "Does not jump round so much, linked to skill level"]
	death_dmg(integer) : "Damage on Death def=120" :  : "Damage on Death"
	poisonous(choices) : "Poison Attack" = [
		0 : "Jump attack (def)"
		1 : "Poison attack"
	]	
	exactskin(choices) : "Skin Selection" = [
	    0 : "Blue (def)"
	    1 : "Grey/Blue" 
	    2 : "Dark/Green" 
	    3 : "Green" 
	    4 : "Yellow/Green"
	    5 : "Green/Yellow" 
	    6 : "Aqua"
	    7 : "Aqua/Brown"
	]
]
//_____WIZARDS_____
@PointClass base(MonTall) model({ "path": "progs/mon_wizard.mdl", "skin": poisonous }) = monster_wizard : "Scrag (Wizard), 80 health points." [
    spawnflags(flags) = [
        4 : "Always Above" : 0 : "Will try to keep above enemy and maintain some distance" 
    ]
    poisonous(choices) : "Poison attack+skin"  :  : "Change skin + poison dmg" = [
        0 : "Default"
        1 : "Poisonous"
    ] 
]
@PointClass base(MonWide) model({{
	spawnflags & 2 ->	{"path":"progs/mon_wraith.mdl", "skin": 4},
	spawnflags & 4 ->	{"path":"progs/mon_wraith.mdl", "skin": 2},
	exactskin >= 0 ->	{"path":"progs/mon_wraith.mdl", "skin": exactskin},
						"progs/mon_wraith.mdl"
}}) = monster_wraith : "Wraith, 350 health points."
[ spawnflags(flags) = [ 
		2 : "Scorpions" : 0 : "Spawn minions(scorpions) to attack the player."
		4 : "Spiders" : 0 : "Spawn minions(spiders) to attack the player."
	]
]
@PointClass base(MonTall) model({{
	spawnflags & 2 -> 	{"path": "progs/mon_skullwiz.mdl", "skin": 3},
	spawnflags & 4 -> 	{"path": "progs/mon_skullwiz.mdl", "skin": 2},
	exactskin >= 1 -> 	{"path": "progs/mon_skullwiz.mdl", "skin": exactskin},
								 "progs/mon_skullwiz.mdl"
}}) = monster_skullwiz : "Skull Wizard, 120 health points."
[ spawnflags(flags) = [ 
		2 : "Guardian" : 0 : "Special version to guard the runes of power." 
		4 : "Minions" : 0 : "Spawn minions (lost souls) to attack the player." 
	]
	target2(target_destination) : "Target2 (info_skullwiz_destination)"
	bodyphased(integer) : "Starts phased out" : : "Spawn phased out and wait to see player."
	bodystatic(integer) : "Prevents teleporting"
	height(integer) : "Maximum Z distance to search for teleport destination"
	distmin(integer) : "Minimum XY distance to search for teleport destination"
    destmax(integer) : "Maximum XY distance to search for teleport destination"	
]
@PointClass base(MonTall) model({{
	//ericw came in and saved it with the below format
	((spawnflags & 2) != 0 && (spawnflags & 4) != 0) -> {"path": "progs/mon_gargoyle.mdl", "skin": 1, "frame": 65},
	spawnflags & 2 -> 	{"path": "progs/mon_gargoyle.mdl", "skin": 1},
	spawnflags & 4 -> 	{"path": "progs/mon_gargoyle.mdl", "frame": 65},
								 "progs/mon_gargoyle.mdl"
}}) = monster_gargoyle : "Gargoyle, 120 health points." [
	spawnflags(flags) = [ 
		2 : "Statue" : 0 : "Stone statue until triggered (always starts in a perched position)."
		4 : "Perch" : 0 : "Start in a sitting down, place 44 units out from perching edge, 4 units higher" 
	]	
]
@PointClass base(MonTall) model({{
	spawnflags & 4 -> 	{"path": "progs/mon_gaunt.mdl"},
	spawnflags ^ 4 -> 	{"path": "progs/mon_gaunt.mdl", "frame": 024}
}}) = monster_gaunt : "Gaunt, 120 health points." [ 
	spawnflags(flags) = [ 4 : "Perch" : 0 : "Start in a sitting position." ] 
]
//_____MINIONS_____
//Minions get no settings, they are precache only
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_lostsoul.mdl") = monster_skullwizminion : "Lost Soul Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_gargoyle.mdl") = monster_minotaurminion : "Gargoyle Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_voreling.mdl") = monster_shalrathminion : "Voreling Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_spiderb.mdl") = monster_wraithminion : "Spider Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_scorpion.mdl") = monster_wraithminion2 : "Scorpion Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/wizard.mdl") = monster_nourminion : "Wizard Minion, used for precache only." []
@PointClass color(255 0 0) offset(0 0 24) flags(Angle) model("progs/mon_gaunt.mdl") = monster_judgeminion : "Gaunt Minion, used for precache only" []

//=============================================================================
// {Patch2 Monsters and MINI Bosses
//=============================================================================

//NEW monster common setup
@baseclass base(AppearFlags) = p2_monsters [
spawnflags(flags) = [
		1 : "Ambush" : 0 : "Wakeup when player is seen"
		8 : "No Sight" : 0 : "No sight sound"
	  16 : "No Idle" : 0 : "No idle sounds (cupboard monster)"
	  32 : "NoGFX" : 0 : "No teleport spawn effect or sound"
	  64 : "Start OFF" : 0 : "Starts OFF, trigger to spawn"
	128 : "Angry" : 0 : "Will spawn angry at the player"
	]
//----- monster common ------
	
	targetname(target_source) : "Name": : "Name of monster used for triggering/targetting"
	target(target_destination) : "Target (path_corner etc)" : : "A path_corner to walk towards or a trigger event on death"
	target2(target_destination) : "Target2 (on death)" : : "Additional trigger events to fire on death of monster (needs target to be defined)"
	health(integer) : "Health (define custom HP's)" :  : "Override health defined in QC"

	angrytarget(target_destination) : "Angry target (on spawn)" : : "Something (monster/player) to get angry at once spawned"
	deathtarget(target_destination) : "Death target (on death)" : : "Entity to trigger upon death (useful if target field already in use)"
	
//----- Infighting/Turret -----
	
	noinfighting(choices) : "Infighting" : : "Set to 1, will not react to any infighting" = [
		0 : "Yes, infighting(def)"
		1 : "NO infighting"
	]
	pain_ignore(choices) : "Infighting Damage" = [
		0 : "Yes(def)"
		1 : "No"
	]
	infightextra(choices) : "Damage Multiplier" : : "Damage multiplier for infighting" = [
		1 : "normal damage" 
		2 : "double damage" 
		4 : "quad damage"
	]
	movespeed(choices) : "Monster Movement(turret)" : : "-1 = no movement(turret), =0/1 free movement (default)" = [
		0 : "Default"
	   -1 : "Stationary(turret)"
		1 : "Free roam"
	]
	turrethealth(integer) : "Health % (for release (0.0->1.0)" : : "Percentage of monster health remaing to release the monster(turret) from being stationary." 
	turrettarget(target_destination) : "Target (on release)" : : "Target(s) to fire when monsters(turret) % HP's triggers release"
	
//----- MISC Settings -----
	
	no_zaware(choices) : "Z-Aware" : : "Set to 1, all Z Aware projectiles will be disabled" = [
		0 : "Yes, z-aware(def)"
		1 : "NO z-aware"	
	]
	no_liquiddmg(choices) : "Liquid Damage" : : "Set to 1, blocks all liquid (slime/lava) damage checks" = [
		0 : "Yes, liquid damage(def)"
		1 : "NO liquid damage"
	]
	gibondeath(choices) : "Gib On Death" = [
		0 : "Default"
		1 : "Shower of gibs"
	]
	bodyfadeaway(integer) : "Body/gibs FADE Time" : : "Time (secs) before body/head will fade away, formula is( TIME + 10 + 0-1 + <bodytimer>)"
	exactskin(integer) : "Exact Skin (not set=random)" :  : "Override default skin 0 (no range check), or leave blank for random."
	nomonstercount(choices) : "Monster Count" : : "Set to 1, excludes from the maps 'initial' monster count" = [
		 0 : "Yes, count (def)"
		 1 : "NO, do not count"
	]
	bboxtype(choices) : "Bounding box size" : : "An advanced setup for advanced mappers ;)" = [
		1 : "Tiny"
		4 : "Short"
		5 : "Tall" 
		7 : "Wide"
		8 : "Giant"
	   10 : "Massive"
	]
]
//_____FLOYD_____
//needs frame 1 specified so he displays correctly in the editor
@PointClass base(p2_monsters) size(-16 -16 -24,16 16 40)  color(255 0 0) model({{  
		spawnflags & 2 ->	{"path": "progs/mon_floyd.mdl", "skin": 1, "frame": 76},
		spawnflags ^ 2 ->	{"path": "progs/mon_floyd.mdl", "skin": 0, "frame": 1}
	}}) = monster_floyd : "Automaton, 150 health points." [
	spawnflags(flags) = [
		2 : "Roll" : 0 : "Start on floor and eventually explode"
	    4 : "Asleep" : 0 : "Start OFF, unless shot or triggered"
	]
]
//Patch2 addition unfinished... closer!!!
//_____BAL TURRET _____
@baseclass = turretbal_unique [

//----- turretbal unique-----
	
	t_length(integer) : "Axis  Restriction (horizontal)" : : "Axis restriction for ceiling/floor version"
	t_width(integer)  : "Axis  Restriction (vertical)" : :  "Axis restriction for wall version"
	attack_count(choices) : "Fire Rate" : : "-1 to disable increased fire rate" = [
	 	 0 : "Default"
	   -1 : "Decreased"
	]
	turretclosing(target_destination) : "Targets fired(closing)" :  : "target(s) fired when turret hides back wall/ceil/floor"
	turretopening(target_destination) : "Targets fired(opening)" :  : "Target(s) fired when turret is coming out to play"
	turretlocked(integer) : "Turret Locked (open)" :  : "Turret will not hide and remain in combat"
	distance(integer) : "Receding Range (def=600)" : : "The range at which the turret will hide (def=600)"
	waitmin3(integer) : "Startup Delay (def=2s)" : : "Time (def=2s) startup delay when spawning at start of map"
	waitmin(integer) : "Closing Delay (def=2s)" : : "Time (def=2s) to pause before hiding if cannot see enemy"
	waitmin2(integer) : "Opening Delay (def=2s)" : : "Time (def=2s) to wait hidden before coming out again"
	wakeup_angle(integer) : "Wakeup Angle Lock (closed)" : : "Angle lock boundary adjustment when turret is closed"		
]
@PointClass base(turretbal_unique, p2_monsters) size(-20 -20 -20,20 20 20) color(192 0 192) model("progs/mon_turretbal.mdl") = monster_turretbal : "Large surface mount turret, 180 health points." [
	spawnflags(flags) = [
		2 : "Triple" : 0 : "Fire triple shot vs single (powerful blast attack)"
	    4 : "Plasma" : 0 : "Fire plasma bolts vs laser (high damage)"
	]
]
//_____SWEEPER_____
@PointClass base(p2_monsters) size(-16 -16 -24, 16 16 24)  color(192 0 192) model("progs/mon_sweeper.mdl") = monster_sweeper : "Slow moving flying robot, 200 health points." [
	spawnflags(flags) = [
		2 : "Lasers" : 0
		4 : "Shield" : 0]]
		
//_____PSYDER_____
@PointClass base(p2_monsters) size(-32 -32 -48, 32 32 48)  color(192 0 192) model("progs/mon_psyder.mdl") = monster_psyder : "Psychic / Psionic stationary dream node, 1200 health points." []

//_____PHOBETOR_____
//Patch2 addition
//_____BARON_____
@PointClass base(p2_monsters) size(-16 -16 -24, 16 16 40) color(192 192 0) model("progs/mon_baron.mdl") = monster_baron : "The Baron - Mini Boss (1200 health points)." [
]
//_____DARK PRINCE_____
@baseclass = dprince_unique [

//----- dprince unique-----
	attack_lifetime(integer) : "Attack Lifetime (secs)" : : "Time that plasma/fire will stay active on floor for damage"
]
@PointClass base(dprince_unique,p2_monsters) size(-16 -16 -24, 16 16 40) color(192 64 0) model("progs/mon_dprince.mdl") = monster_dprince : "Dark Prince, Mini Boss! (1200 health points)" [
	spawnflags(flags) =[ 2 : "Fire Attack" : 0 : "Fire attack vs Plasma" ]	
]
//_____MEGA ENFORCER____
@PointClass base(p2_monsters) size(-16 -16 -24, 16 16 40) color(0 255 128) model("progs/mon_megaforce.mdl") = monster_megaforce : "A Mega Enforcer, 400 health points." []
//_____DEFLECTOR____
@PointClass base(p2_monsters) size(-16 -16 -24, 16 16 40) color(0 255 128) model({{
	spawnflags & 2 -> {"path": "progs/mon_deflector.mdl", "skin": 1},
	"progs/mon_deflector.mdl"}}) = monster_deflector : "The Deflector, 1200 health points." [
	spawnflags(flags) = [ 2 : "Plasma" : 0 : "Plasma Deflector" ]
	attack_rage(integer) : "Burst mode for flame/plasma attack (def=ON, 1=ON, -1=OFF)"
	proj_limit(integer) : "Maximum amount of sprite flames active (def=64, burst=32)"
	proj_attqty(integer) : "Proj Count = Base (X) * (Skill * Y) Maximum = Z (def='3 2 7')"
	dpp_flame(integer) : "Random chance of extra particles on flame (def=0.02)"
	part_exitpuff(integer) : "When flame sprite is finished show puff of smoke (def=ON)"
	part_exitsound(integer) : "Clear all sound channels when flame is finished (def=ON)"
]
//_____MAMMOTH____
@PointClass base(p2_monsters) size(-32 -32 -24,32 32 96) color(192 0 192) model("progs/mon_mammoth1.mdl") = monster_mammoth : "Slow moving mini boss robot, 1200 health points." []
//_____JUDICATOR + JUSTICE____
@PointClass base(p2_monsters, JumpingMon) size(-32 -32 -24,32 32 64) color(192 0 192) model({{
	spawnflags & 4 -> {"path": "progs/mon_judge.mdl", "skin": 1},
	"progs/mon_judge.mdl"}}) = monster_judicator : "The Judicator, BOSS setup with multiple waves" [
	spawnflags(flags) = [
		1 : "Ambush" : 0 : "Wakeup when player is seen"
		4 : "Blue Flames" : 0 : "Flame attacks use blue sprites and explosions"
		8 : "No Sight" : 0 : "No sight sound"
		16 : "No Idle" : 0 : "No idle sounds (cupboard monster)"
		32 : "NoGFX" : 0 : "No teleport spawn effect or sound"
		64 : "Start OFF" : 0 : "Start OFF, trigger to Spawn"
		128 : "Angry" : 0 : "Will spawn angry at the player"
		]
	targetname(target_source) : "Name" : : "Name of monster used for triggering/reference"
	target(string) : "A path_corner to walk towards or a trigger event on death"
	angrytarget(string) : "something (monster/player) to get angry at once spawned"
	deathtarget(string) : "Additional trigger events to fire on death (not BOSS)"
	nomonstercount(choices) : "No Monster Count" : : "Set to 1 to exclude it from the maps 'initial' monster count" = [
		 0 : "Yes, count (def)"
		 1 : "NO, do not count"
		]
	delaymonstercount(integer) : "Exclude from initial monster count, wait for delay spawn"
	tethertarget(string) : "target of tether entity for tethering system (required!)"
	tetherrange(integer) : "The circular range around tether point (BOSS def=325)"
	bosswave(integer) : "Total amount of boss waves (1-4)"
	bosswaveqty(integer) : "Total amount of health per wave"
	message(string) : "Intro trigger"
	noise1(string) : "Wave 1 entities to trigger"
	noise2(string) : "Wave 2 entities to trigger"
	noise3(string) : "Wave 3 entities to trigger"
]
@PointClass base(p2_monsters, JumpingMon) size(-16 -16 -24,16 16 56) color(192 0 192) model({{
	exactskin >= 1 -> 	{"path": "progs/mon_justice.mdl", "skin": exactskin},
	"progs/mon_justice.mdl"}}) = monster_justice : "Justice, 500 health points" [
	spawnflags(flags) = [
		1 : "Ambush" : 0 : "Wakeup when player is seen"
		8 : "No Sight" : 0 : "No sight sound"
		16 : "No Idle" : 0 : "No idle sounds (cupboard monster)"
		32 : "NoGFX" : 0 : "No teleport spawn effect or sound"
		64 : "Start OFF" : 0 : "Start OFF, trigger to Spawn"
		128 : "Angry" : 0 : "Will spawn angry at the player"
		]
	targetname(target_source) : "Name of monster used for triggering/reference"
	target(target_destination) : "A path_corner to walk towards or a trigger event on death"
	target2(target_destination) : "Additional trigger events to fire on death of monster"
	angrytarget(target_destination) : "Something (monster/player) to get angry at once spawned"
	deathtarget(target_destination) : "Entity to trigger upon death (use if target field in use)"
	health(integer) : "Override default health settings (default is 500)"
	exactskin(choices) : "Exact Skin" : : "Override default skin selection of 0 (no error checking)" = [
		0 : "Default Skin"
		1 : "Red variation"
		2 : "Blue Variation"
		3 : "Blue with lit helmet"
		]
	nomonstercount(integer) : "1 will exclude from initial monster count, will add if killed"
	infightextra(integer) : "Damage multiplier for infighting damage"
	pain_ignore(integer) : "1 = Ignore pain when hit by other monsters"
	noinfighting(integer) : "Will not react to any infighting (it can look stupid)"
	no_liquiddmg(integer) : "Blocks all liquid (slime/lava) damage checks"
	no_zaware(integer) : "All Z Aware projectiles will be disabled"
	bboxtype(integer) : "Change bbox 1=Tiny,4=Short,5=Tall,7=Wide,8=Giant,10=Massive"
	gibondeath(integer) : "1 = always explode in a shower of gibs on death"
	bodyfadeaway(integer) : "Time (secs) before body/head will fade away (default=0)"
	movespeed(integer) : "-1 : no movement(turret), =0/1 free movement (default)"
	turrethealth(integer) : "0.0->1.0; % of HP when monster is released"
	turrettarget(integer) : "Target(s) to fire when monster % HP is reached"
]
	
//=============================================================================
// MINI Bosses
//=============================================================================

//_____BOG LORD_____
@PointClass base(p2_monsters) size(-16 -16 -24, 16 16 40) color(255 0 0) model({{
	spawnflags & 2 -> 	{"path": "progs/mon_bossboglord.mdl", "skin": 1},
								"progs/mon_bossboglord.mdl"
}}) = monster_boglord : "Pray you NEVER meet... Lord of the Bog! 1200+ Health Points." [
	spawnflags(flags) = [ 2 : "FIRE (2K HP's)" : 0 : "Red/Fire version with more health (2k) and Skin 2" ]
]
//_____NOUR_____
@PointClass base(AppearFlags) size(-16 -16 -24, 16 16 40) color(255 0 0) model("progs/mon_bossnour.mdl") = monster_nour : "Nouronihar, 1200 Health Points." [
	spawnflags(flags) = [
		1 : "Ambush" : 0 : "Wakeup when player is seen"
		2 : "BOSS" : 0 : "Version with waves and minion spawns" 
		8 : "No Sight" : 0 : "No sight sound"
		16 : "No Idle" : 0 : "No idle sounds (cupboard monster)"
		32 : "NoGFX" : 0 : "No teleport spawn effect or sound"
		64 : "Start OFF" : 0 : "Start OFF, trigger to Spawn"
		128 : "Angry" : 0 : "Will spawn angry at the player"
	]
	targetname(target_source) : "Name" : : "Name of monster used for triggering/reference"
	target(string) : "Wave Final trigger"
	health(integer) : "Health (define custom HP's)" :  : "Override health defined in QC"
	angrytarget(target_destination) : "Angry target (on spawn)" : : "Something (monster/player) to get angry at once spawned"
	deathtarget(target_destination) : "Death target (on death)" : : "Entity to trigger upon death (useful if target field already in use)"
	exactskin(integer) : "Model Skin number" :  : "Override default skin (no range check)"
	nomonstercount(choices) : "No Monster Count" : : "Set to 1 to exclude it from the maps 'initial' monster count" = [
		 0 : "Yes, count (def)"
		 1 : "NO, do not count"
	]
	delaymonstercount(choices) : "Delay Monster Count" : : "Exclude from initial monster count, wait for delay spawn" = [
		 0 : "Yes, count (def)"
		 1 : "NO, do not count"
	]
	tethertarget(string) : "target of tether entity for tethering system (boss=required)"
	tetherrange(integer) : "The circular range around tether point (boss def=325)"
	noise(string) : "Intro burst trigger (breakables?)"
	bosswave(integer) : "Total amount of boss waves (1-4) (Boss Only)"
	bosswaveqty(integer) : "Total amount of health per wave (Boss Only)"
	noise1(string) : "Wave 1 trigger"
	noise2(string) : "Wave 2 trigger"
	noise3(string) : "Wave 3 trigger"
	attack_chance(integer) : "Percentage (0-1) chance of spit attack vs bomb attack"
]
//=============================================================================
// SPECIAL BOSS SETUPS
//=============================================================================

//_____CHTHON_____
@PointClass size(-80 -80 -24, 80 80 256) color(255 0 0 ) model("progs/mon_bosschthon.mdl") = monster_boss : "Chthon (Boss of Shareware Quake)." []
@PointClass size(-80 -80 -24, 80 80 256) color(255 0 0 ) model({{
	spawnflags & 2 ->		{"path": "progs/mon_bosschthon.mdl", "skin": 1},
	spawnflags & 4 ->		{"path": "progs/mon_bosschthon.mdl", "skin": 2},
									":progs/mon_bosschthon.mdl"
	}}) = monster_chthon  : "Chthon (Custom version)." [
	spawnflags(flags) = [ 
		2 : "Red (new)" : 0: "New red skin with plenty of upward lighting+shadow"
		4 : "Green" : 0 : "Green skin + slime balls instead of lava"
	]
	targetname(string) : "monster / trigger name"
	target(string) : "Wave Final trigger"
	bosswave(integer) : "Total boss waves (1-5)"
	bosswaveqty(integer) : "Health each wave"
	bosswaveuse(integer) : "If set to 1, lets waves advance via use/triggers"
	resist_shells(integer) : "Shell resistance (0-1)"
	resist_nails(integer) : "Nail resistance (0-1)"
	resist_rockets(integer) : "Rocket reistance (0-1)"
	resist_cells(integer) : "Cell resistance (0-1)"
	pos1(string) : "Att1 Speed Base/Skill/- (250 50 0)"
	pos2(string) : "Att1 Dmg Base/Rnd/Splash (100 20 120)"
	pos3(string) : "Att2 Forward/Up/Dmg (300 500 40)"
	dest2(string) : "Att2 Spawn location (0 0 96)"
	noise1(string) : "Wave 1 trigger"
	noise2(string) : "Wave 2 trigger"
	noise3(string) : "Wave 3 trigger"
	noise4(string) : "Wave 4 trigger"
	deathtype(string) : "Death message (optional)"
]
@PointClass base(AppearFlags, targetname) size(-16 -16 -16, 16 16 16) color(0 255 255) = event_lightning : "Chthon's lightning. Just for boss level. Used for killing Cthon." []
//_____SHUB_____
@PointClass size(-128 -128 -24, 128 128 192) color(255 0 0 ) model("progs/oldone.mdl") = monster_oldone : "Shub-Niggurath, 40000 health points." []
@PointClass size(-128 -128 -24, 128 128 192) color(255 0 0 ) model("progs/oldone.mdl") = monster_shub : "Shub-Niggurath (Custom version)."
[
	spawnflags(flags) = [ 2 : "Dmg TRIG" : 0 : "Will start attacking if damaged" ]
	targetname(string) : "monster / trigger name"
	target(string) : "Wave Final trigger"
	bosswave(integer) : "Total boss waves (1-5)"
	bosswaveqty(integer) : "Health each wave"
	resist_shells(integer) : "Shell resistance (0-1)"
	resist_nails(integer) : "Nail resistance (0-1)"
	resist_rockets(integer) : "Rocket reistance (0-1)"
	resist_cells(integer) : "Cell resistance (0-1)"
	pos1(string) : "Att1 Speed Base/Skill/- (200 20 0)"
	pos2(string) : "Att1 Dmg Base/Rnd/Splash (0 0 40)"
	pos3(string) : "Att2 Forward/Up/Dmg (300 500 40)"
	dest1(string) : "Att1 Spawn location (0 0 128)"
	dest2(string) : "Att2 Spawn location (0 0 128)"
	noise1(string) : "Wave 1 trigger"
	noise2(string) : "Wave 2 trigger"
	noise3(string) : "Wave 3 trigger"
	noise4(string) : "Wave 4 trigger"
	deathtype(string) : "Death message (optional)"
]
@PointClass size(-128 -128 -192, 128 128 24) color(255 0 0) model("progs/oldone.mdl") = monster_shubupsd : "Shub-Niggurath, (Up Side Down Custom version)."
[
	spawnflags(flags) = [ 2 : "Dmg TRIG" : 0 : "Will start attacking if damaged" ]
	targetname(string) : "monster / trigger name"
	target(string) : "Wave Final trigger"
	bosswave(integer) : "Total boss waves (1-5)"
	bosswaveqty(integer) : "Health each wave"
	resist_shells(integer) : "Shell resistance (0-1)"
	resist_nails(integer) : "Nail resistance (0-1)"
	resist_rockets(integer) : "Rocket reistance (0-1)"
	resist_cells(integer) : "Cell resistance (0-1)"
	pos1(string) : "Att1 Speed Base/Skill/- (200 20 0)"
	pos2(string) : "Att1 Dmg Base/Rnd/Splash (0 0 40)"
	pos3(string) : "Att2 Forward/Up/Dmg (600 0 40)"
	dest1(string) : "Att1 Spawn location (0 0 128)"
	dest2(string) : "Att2 Spawn location (0 0 128)"
	noise1(string) : "Wave 1 trigger"
	noise2(string) : "Wave 2 trigger"
	noise3(string) : "Wave 3 trigger"
	noise4(string) : "Wave 4 trigger"
	deathtype(string) : "Death message (optional)"
]
@PointClass base(AppearFlags, targetname) size(-8 -8 -8, 8 8 8) color(0 125 200) = misc_teleporttrain : "Shub-Niggurath Flying ball. NOTE: This is used for the final boss ONLY. Flying ball needed to teleport kill Shub-Niggurath. Originally used bmodel train functions, setup to work like the shalrath homing missile." []
//_____ICE GOLEM_____
@PointClass size(-32 -32 -24, 32 32 128) color(255 0 0) model("progs/mon_bossicegolem.mdl") = monster_icegolem : "Ice Golem, a Frozen Guardian in a cave." [
	targetname(string) : "Name"
	target(string) : "Wave Final trigger"
	noise1(string) : "Wave 1 trigger ent"
	noise2(string) : "Wave 2 trigger ent"
	noise3(string) : "Wave 3 trigger ent"
	noise4(string) : "Wave 4 trigger ent"
	brkobj1(string) : "Ceiling rubble bmodel (maps/ad_brk/rock01.bsp)"
	brkobj2(string) : "Ceiling rubble bmodel (maps/ad_brk/rock02.bsp)"
	dest1(integer) : "Rubble colour range x->y,z (base/qty)"
	dest2(integer) : "Rubble emitter offset downward (X/Y/Z def=0 0 16)"
	brkvol(integer) : "Rubble emitter size (X/Y/Z def=160 160 8)"
	brkvelbase(integer) : "Rubble base velocity (def=0 0 50)"
	brkveladd(integer) : "Rubble add velocity (def=100 100 100)"
	brkfade(integer) : "Rubble fade timeout (def=4)"
]
@PointClass size(-32 -32 -8, 32 32 8) = monster_icegolem_wavetrig : "Ice Golem Wave Trigger, target for boss column smash wave event." [
	targetname(string) : "Name of wave event"
	target(string) : "Trigger Wave Adds"
	noise1(string) : "Trigger Event 1"
	noise2(string) : "Trigger Event 2"
]
//_____EIDOLON_____
@PointClass size(-32 -32 -24, 32 32 128) model({"path": "progs/mon_bosseidolon.mdl", "skin": 1}) = monster_eidolon : "Eidolon, Boss that starts behind a shield." [
	targetname(string) : "monster / trigger name"
	target(string) : "Wave Final trigger"
	noise1(string) : "Wave 1 trigger ent"
	noise2(string) : "Wave 2 trigger ent"
	noise3(string) : "Wave 3 trigger ent"
	noise4(string) : "Wave 4 trigger ent"
]
@PointClass base(AppearFlags) size(-32 -32 -4, 32 32 4) = monster_eidolon_wavetrig : "Eidolon Wave Trigger, target for boss lightning wave event." [
	targetname(string) : "Name of wave event"
	target(string) : "Trigger Wave Adds"
	target2(string) : "Trigger Event"
	noise(string) : "Collision Model"
]

//============================================================================
//
//Editor/Compiler/Engine special USE 'func_ ' Entities
//
//============================================================================

// _____WALL_____
@SolidClass base(AppearFlags,targetname,FuncLighting) = func_wall : "Wall - A SOLID BModel(brushwork) that does not split world faces and has toggleable animated texture abilities(referred to as AFrame). See 'trigger_entitystate_aframe' for more details." [
	spawnflags(Flags) = [
		2 : "AFRAME" : 0 : "Start with the A frame animated texture"
		16: "Mod Check" : 0 : "Will remove this entity if THIS mod is active"
		32: "Static" : 0 : "Turn entity into static upon spawn (frame 0)"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]
	alphastart(integer) : "Alpha Fade bmodel (range 0.01-1.00) = Starting value"
	waitmin(integer) : "Alpha Fade Time (def=1s) of bmodel (even if partial)"
	lip(integer) : "Alpha Fade Direction -1=Down(1<-0), 1=Up(0->1), Def=UP"
	delay(integer) : "Alpha Fade delay to start of fading (def=0)"
]
//_____ILLUSIONARY_____
@SolidClass base(AppearFlags, targetname, FuncLighting) = func_illusionary : "A NON-SOLID BModel(brushwork), yes you can walk right through it, that gives the 'illusion' of solid brushwork. Since they are textured with normal world textures. Typically used for secrets. NOTE - Also has 'AFrame' ability to texture toggle, see 'trigger_entitystate_aframe' for more details." [
	spawnflags(Flags) = [
		2 : "AFRAME" : 0 : "Start with the A frame animated texture"
	   32: "Static" : 0 : "Turn entity into static upon spawn (frame 0)"
	   64 : "Start OFF" : 0 : "Starts off, waits for trigger"
	]	
	alphastart(integer) : "Alpha Fade bmodel (range 0.01-1.00) = Starting value"
	waitmin(integer) : "Alpha Fade Time (def=1s) of bmodel (even if partial)"
	lip(integer) : "Alpha Fade Direction -1=Down(1<-0), 1=Up(0->1), Def=UP"
	delay(integer) : "Alpha Fade delay to start of fading (def=0)"
]
//_____DETAIL_____
@SolidClass base(FuncLighting) = func_detail : "Compiler entity only. Brushwork that does not seal the map or is structural. Detail brushes add visual details to the world but do NOT block visibility. 'func_detail' entities are merged into the worldspawn entity by the qbsp compiler and do not appear as separate entities in the compiled bsp. NOTE - While effecient use of detail brushes drastically cuts down on the more complex and larger levels, it is a good technique to develop early on. Especially as a time saver for later when your skills and ambitions will require it." []
//_____GROUP_____
@SolidClass base(FuncLighting) = func_group : "Group brushes together for editing convenience. 'func_group' entitites, like 'func_detail', are merged into the worldspawn entity by the qbsp compiler and do not appear as separate entities in the compiled bsp." []

// NOTE: AFAIK(from testing) - Only func_detail_fence and func_detail_illusionary, func_water also, can USE 
// _mirrorinside 1

//_____DETAIL FENCE_____
@SolidClass base(FuncLighting) = func_detail_fence : "Similar to 'func_detail_wall' except its suitable for fence(alphamasked) textures and never clips away world faces. Useful for fences, grates, etc, that are solid and block gunfire. NOTE: Set _mirriorinside to 1 to texture inside faces. See 'func_detail_illusionary' for more information." [   
    _mirrorinside(choices) : "Mirror Inside Face(s)" = [
	    0 : "Do Nothing"
	    1 : "Enabled"
	]    
]
//_____DETAIL ILLUSIONARY_____
@SolidClass base(FuncLighting) = func_detail_illusionary : "Compiler entity only. A func_detail variant with no collision(players|monsters|gunfire) and doesnt split world faces. Useful for hanging vines. NOTE: Set '_mirriorinside' to 1 to texture inside faces. Example - You have a brush textured entirely with the 'skip' texture except for one face, which is textured with 'cobwebs'. Setting '_mirrorinside' to 1 will mirror your cobweb texture to the inside of that face." [
    _mirrorinside(choices) : "Mirror Inside Face(s)" = [
	    0 : "Do Nothing"
	    1 : "Enabled"
	]    
]
//_____DETAIL WALL_____
@SolidClass base(FuncLighting) = func_detail_wall : "Compiler entity only. A func_detail variant that doesnt split world faces. Useful for when you want decoration touching a floor, or wall, to not split the floor/wall faces. Note: You will get some overdraw instead. If it completely covers up a world face, that face will get clipped away. So it is not suitable for fence(alphamasked) textures." []

// *** ADVANCED ***

//_____ILLUSIONARY VISBLOCKER_____
@SolidClass base(FuncLighting) = func_illusionary_visblocker : "For creating *vis-blocking* illusionary brushes. The player can walk through them. This gives the same effect as water brushes when the '-notranswater' flag is used, except the interior of these brushes are saved as CONTENTS_EMPTY. NOTE - If the player's view is very close to the faces of these brushes they might be able to see into the void (depending on the engine). Fitzquake family engines have a workaround for this that is enabled if the brushes are textured with a water texture ('*' prefixed)." []

//============================================================================
//
//Editor/Compiler EXTERNAL MAP PREFAB feature
//
//============================================================================

//_____external_map Settings_____
@baseclass = ExternalMapSettings [
     _external_map(string) : "Map Path" :  : "ABSOLUTE path to the external '.map' file. For example,  'c:\quake\id1\maps\myprefab.map'."
    _external_map_classname(choices) : "Entity class" :  : "Turn the imported bruskwork into a func_(class) entity (ex func_detail) NOTE - You can use 'Smart Edit' to set '_external_map_classname' to any func_(class) entity you like, and add keys appropriate for that class. However, it is beyond the scope of this entry to try and encompass every possibility covering every entity type so only a small set of 'choices' are listed." = [
        "func_detail" : "func_detail"
        "func_group"  : "func_group"
        "func_wall"   : "func_wall"
        "func_illusionary" : "func_illusionary"
        "func_detail_wall" : "func_detail_wall"
        "func_detail_illusionary" : "func_detail_illusionary"    
    ]
    _external_map_angle(integer) : "Rotation (y-axis only)": : "Short version of _external_map_angles for when you want to specify just a yaw rotation."
    _external_map_angles(integer) : "Rotation(x y z)" :  : "Final Entity Angle Orientation, pitch yaw and roll(X Y Z) axis. Negative pitch is down."
    _external_map_scale(string) : "Scale" :  : "Final Entity Scale (default='1 1 1' X Y Z axis)" 
]
//_____EXTERNAL MAP_____
@PointClass base(FuncItems,ExternalMapSettings,FuncLighting) size(-24 -24 -16, 24 24 16) color(255 25 25) = misc_external_map : "Import an external '.map's brushwork into your world geometry. Only brushes, or func_group, in the worldspawn of the imported map is used, everything else is ignored. The imported  brushwork can then have rotations applied, specified by the '_external_map_angle(s)' key(s), which then is translated  to the origin key of the 'misc_external_map' entity. This is a *compiler* entity only. NOTE: Texture .wad's used in the external map MUST be used in the map you are importing into." []


